{"ast":null,"code":"import { jsx as w, jsxs as K, Fragment as Q } from \"react/jsx-runtime\";\nimport ee, { createContext as te, useState as j, useMemo as z, useRef as O, useContext as M, useEffect as A, memo as he, forwardRef as B, useLayoutEffect as L, useImperativeHandle as oe, useCallback as ae } from \"react\";\nimport * as h from \"three\";\nimport { NoToneMapping as _e, HalfFloatType as xe, Vector3 as ge, Uniform as y, TextureLoader as we, SRGBColorSpace as Se, RepeatWrapping as Y, Texture as ye, Color as Pe, CanvasTexture as be, NearestFilter as re } from \"three\";\nimport { useThree as V, useFrame as J, extend as Ee, createPortal as Re, useLoader as Ue, applyProps as Ce } from \"@react-three/fiber\";\nimport { EffectComposer as ze, RenderPass as Te, NormalPass as Ae, DepthDownsamplingPass as Be, Effect as W, EffectPass as Ve, Pass as Fe, DepthOfFieldEffect as Me, MaskFunction as De, DepthPickingPass as ke, CopyPass as Ge, BloomEffect as Ie, BrightnessContrastEffect as Le, ChromaticAberrationEffect as Ne, ColorAverageEffect as je, ColorDepthEffect as Oe, DepthEffect as We, DotScreenEffect as Xe, GlitchEffect as qe, GlitchMode as ne, GodRaysEffect as He, GridEffect as Ze, HueSaturationEffect as $e, NoiseEffect as Ke, OutlineEffect as Ye, PixelationEffect as Je, ScanlineEffect as Qe, SelectiveBloomEffect as et, SepiaEffect as tt, SSAOEffect as ot, SMAAEffect as at, FXAAEffect as rt, TextureEffect as nt, ToneMappingEffect as st, VignetteEffect as it, ShockWaveEffect as lt, LUT3DEffect as ct, TiltShiftEffect as ft } from \"postprocessing\";\nimport { easing as se } from \"maath\";\nimport { N8AOPostPass as ut } from \"n8ao\";\nconst H = /*@__PURE__*/te(null);\nfunction pt({\n  children: e,\n  enabled: t = !0\n}) {\n  const [o, r] = j([]),\n    a = z(() => ({\n      selected: o,\n      select: r,\n      enabled: t\n    }), [o, r, t]);\n  return /*@__PURE__*/w(H.Provider, {\n    value: a,\n    children: e\n  });\n}\nfunction mt({\n  enabled: e = !1,\n  children: t,\n  ...o\n}) {\n  const r = O(null),\n    a = M(H);\n  return A(() => {\n    if (a && e) {\n      let n = !1;\n      const i = [];\n      if (r.current.traverse(s => {\n        s.type === \"Mesh\" && i.push(s), a.selected.indexOf(s) === -1 && (n = !0);\n      }), n) return a.select(s => [...s, ...i]), () => {\n        a.select(s => s.filter(l => !i.includes(l)));\n      };\n    }\n  }, [e, t, a]), /*@__PURE__*/w(\"group\", {\n    ref: r,\n    ...o,\n    children: t\n  });\n}\nconst D = /*@__PURE__*/te(null),\n  ie = e => (e.getAttributes() & 2) === 2,\n  dt = /*@__PURE__*/he(/*@__PURE__*/B(({\n    children: e,\n    camera: t,\n    scene: o,\n    resolutionScale: r,\n    enabled: a = !0,\n    renderPriority: n = 1,\n    autoClear: i = !0,\n    depthBuffer: s,\n    enableNormalPass: l,\n    stencilBuffer: p,\n    multisampling: _ = 8,\n    frameBufferType: S = xe\n  }, g) => {\n    const {\n        gl: d,\n        scene: m,\n        camera: v,\n        size: x\n      } = V(),\n      f = o || m,\n      u = t || v,\n      [c, U, b] = z(() => {\n        const C = new ze(d, {\n          depthBuffer: s,\n          stencilBuffer: p,\n          multisampling: _,\n          frameBufferType: S\n        });\n        C.addPass(new Te(f, u));\n        let R = null,\n          E = null;\n        return l && (E = new Ae(f, u), E.enabled = !1, C.addPass(E), r !== void 0 && (R = new Be({\n          normalBuffer: E.texture,\n          resolutionScale: r\n        }), R.enabled = !1, C.addPass(R))), [C, E, R];\n      }, [u, d, s, p, _, S, f, l, r]);\n    A(() => c?.setSize(x.width, x.height), [c, x]), J((C, R) => {\n      if (a) {\n        const E = d.autoClear;\n        d.autoClear = i, p && !i && d.clearStencil(), c.render(R), d.autoClear = E;\n      }\n    }, a ? n : 0);\n    const F = O(null);\n    L(() => {\n      const C = [],\n        R = F.current.__r3f;\n      if (R && c) {\n        const E = R.children;\n        for (let T = 0; T < E.length; T++) {\n          const N = E[T].object;\n          if (N instanceof W) {\n            const q = [N];\n            if (!ie(N)) {\n              let G = null;\n              for (; (G = E[T + 1]?.object) instanceof W && !ie(G);) q.push(G), T++;\n            }\n            const $ = new Ve(u, ...q);\n            C.push($);\n          } else N instanceof Fe && C.push(N);\n        }\n        for (const T of C) c?.addPass(T);\n        U && (U.enabled = !0), b && (b.enabled = !0);\n      }\n      return () => {\n        for (const E of C) c?.removePass(E);\n        U && (U.enabled = !1), b && (b.enabled = !1);\n      };\n    }, [c, e, u, U, b]), A(() => {\n      const C = d.toneMapping;\n      return d.toneMapping = _e, () => {\n        d.toneMapping = C;\n      };\n    }, [d]);\n    const X = z(() => ({\n      composer: c,\n      normalPass: U,\n      downSamplingPass: b,\n      resolutionScale: r,\n      camera: u,\n      scene: f\n    }), [c, U, b, r, u, f]);\n    return oe(g, () => c, [c]), /*@__PURE__*/w(D.Provider, {\n      value: X,\n      children: /*@__PURE__*/w(\"group\", {\n        ref: F,\n        children: e\n      })\n    });\n  })),\n  k = e => typeof e == \"object\" && e != null && \"current\" in e ? e.current : e;\nlet vt = 0;\nconst le = /*@__PURE__*/new WeakMap(),\n  P = (e, t) => function ({\n    blendFunction: o = t?.blendFunction,\n    opacity: r = t?.opacity,\n    ...a\n  }) {\n    let n = le.get(e);\n    if (!n) {\n      const l = `@react-three/postprocessing/${e.name}-${vt++}`;\n      Ee({\n        [l]: e\n      }), le.set(e, n = l);\n    }\n    const i = V(l => l.camera),\n      s = ee.useMemo(() => [...(t?.args ?? []), ...(a.args ?? [{\n        ...t,\n        ...a\n      }])], [JSON.stringify(a)]);\n    return /*@__PURE__*/w(n, {\n      camera: i,\n      \"blendMode-blendFunction\": o,\n      \"blendMode-opacity-value\": r,\n      ...a,\n      args: s\n    });\n  },\n  Z = (e, t) => {\n    const o = e[t];\n    return ee.useMemo(() => typeof o == \"number\" ? new h.Vector2(o, o) : o ? new h.Vector2(...o) : new h.Vector2(), [o]);\n  },\n  ce = /*@__PURE__*/B(function ({\n    blendFunction: e,\n    worldFocusDistance: t,\n    worldFocusRange: o,\n    focusDistance: r,\n    focusRange: a,\n    focalLength: n,\n    bokehScale: i,\n    resolutionScale: s,\n    resolutionX: l,\n    resolutionY: p,\n    width: _,\n    height: S,\n    target: g,\n    depthTexture: d,\n    ...m\n  }, v) {\n    const {\n        camera: x\n      } = M(D),\n      f = g != null,\n      u = z(() => {\n        const c = new Me(x, {\n          blendFunction: e,\n          worldFocusDistance: t,\n          worldFocusRange: o,\n          focusDistance: r,\n          focusRange: a,\n          focalLength: n,\n          bokehScale: i,\n          resolutionScale: s,\n          resolutionX: l,\n          resolutionY: p,\n          width: _,\n          height: S\n        });\n        f && (c.target = new ge()), d && c.setDepthTexture(d.texture, d.packing);\n        const U = c.maskPass;\n        return U.maskFunction = De.MULTIPLY_RGB_SET_ALPHA, c;\n      }, [x, e, t, o, r, a, n, i, s, l, p, _, S, f, d]);\n    return A(() => () => {\n      u.dispose();\n    }, [u]), /*@__PURE__*/w(\"primitive\", {\n      ...m,\n      ref: v,\n      object: u,\n      target: g\n    });\n  }),\n  ht = /*@__PURE__*/B(({\n    target: e = void 0,\n    mouse: t = !1,\n    debug: o = void 0,\n    manual: r = !1,\n    smoothTime: a = .25,\n    ...n\n  }, i) => {\n    const s = O(null),\n      l = O(null),\n      p = O(null),\n      _ = V(({\n        scene: b\n      }) => b),\n      S = V(({\n        pointer: b\n      }) => b),\n      {\n        composer: g,\n        camera: d\n      } = M(D),\n      [m] = j(() => new ke()),\n      [v] = j(() => new Ge());\n    A(() => (g.addPass(m), g.addPass(v), () => {\n      g.removePass(m), g.removePass(v);\n    }), [g, m, v]), A(() => () => {\n      m.dispose(), v.dispose();\n    }, [m, v]);\n    const [x] = j(() => new h.Vector3(0, 0, 0)),\n      [f] = j(() => new h.Vector3(0, 0, 0)),\n      u = ae(async (b, F) => (f.x = b, f.y = F, f.z = await m.readDepth(f), f.z = f.z * 2 - 1, 1 - f.z > 1e-7 ? f.unproject(d) : !1), [f, m, d]),\n      c = ae(async (b, F = !0) => {\n        if (e) x.set(...e);else {\n          const {\n              x: X,\n              y: C\n            } = t ? S : {\n              x: 0,\n              y: 0\n            },\n            R = await u(X, C);\n          R && x.copy(R);\n        }\n        F && s.current?.target && (a > 0 && b > 0 ? se.damp3(s.current.target, x, a, b) : s.current.target.copy(x));\n      }, [e, x, t, u, a, S]);\n    J(async (b, F) => {\n      r || c(F), l.current && l.current.position.copy(x), p.current && s.current?.target && p.current.position.copy(s.current.target);\n    });\n    const U = z(() => ({\n      dofRef: s,\n      hitpoint: x,\n      update: c\n    }), [x, c]);\n    return oe(i, () => U, [U]), /*@__PURE__*/K(Q, {\n      children: [o ? Re(/*@__PURE__*/K(Q, {\n        children: [/*@__PURE__*/K(\"mesh\", {\n          ref: l,\n          children: [/*@__PURE__*/w(\"sphereGeometry\", {\n            args: [o, 16, 16]\n          }), /*@__PURE__*/w(\"meshBasicMaterial\", {\n            color: \"#00ff00\",\n            opacity: 1,\n            transparent: !0,\n            depthWrite: !1\n          })]\n        }), /*@__PURE__*/K(\"mesh\", {\n          ref: p,\n          children: [/*@__PURE__*/w(\"sphereGeometry\", {\n            args: [o / 2, 16, 16]\n          }), /*@__PURE__*/w(\"meshBasicMaterial\", {\n            color: \"#00ff00\",\n            opacity: .5,\n            transparent: !0,\n            depthWrite: !1\n          })]\n        })]\n      }), _) : null, /*@__PURE__*/w(ce, {\n        ref: s,\n        ...n,\n        target: x\n      })]\n    });\n  }),\n  _t = {\n    fragmentShader: `\n    uniform float time;\n    uniform vec2 lensPosition;\n    uniform vec2 screenRes;\n    uniform vec3 colorGain;\n    uniform float starPoints;\n    uniform float glareSize;\n    uniform float flareSize;\n    uniform float flareSpeed;\n    uniform float flareShape;\n    uniform float haloScale;\n    uniform float opacity;\n    uniform bool animated;\n    uniform bool anamorphic;\n    uniform bool enabled;\n    uniform bool secondaryGhosts;\n    uniform bool starBurst;\n    uniform float ghostScale;\n    uniform bool aditionalStreaks;\n    uniform sampler2D lensDirtTexture;\n    vec2 vTexCoord;\n    \n    float rand(float n){return fract(sin(n) * 43758.5453123);}\n\n    float noise(float p){\n      float fl = floor(p);\n      float fc = fract(p);\n      return mix(rand(fl),rand(fl + 1.0), fc);\n    }\n\n    vec3 hsv2rgb(vec3 c)\n    {\n      vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);\n      return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);\n    }\n\n    float saturate(float x)\n    {\n      return clamp(x, 0.,1.);\n    }\n\n    vec2 rotateUV(vec2 uv, float rotation)\n    {\n      return vec2(\n          cos(rotation) * uv.x + sin(rotation) * uv.y,\n          cos(rotation) * uv.y - sin(rotation) * uv.x\n      );\n    }\n\n    // Based on https://www.shadertoy.com/view/XtKfRV\n    vec3 drawflare(vec2 p, float intensity, float rnd, float speed, int id)\n    {\n      float flarehueoffset = (1. / 32.) * float(id) * 0.1;\n      float lingrad = distance(vec2(0.), p);\n      float expgrad = 1. / exp(lingrad * (fract(rnd) * 0.66 + 0.33));\n      vec3 colgrad = hsv2rgb(vec3( fract( (expgrad * 8.) + speed * flareSpeed + flarehueoffset), pow(1.-abs(expgrad*2.-1.), 0.45), 20.0 * expgrad * intensity)); //rainbow spectrum effect\n\n      float internalStarPoints;\n\n      if(anamorphic){\n        internalStarPoints = 1.0;\n      } else{\n        internalStarPoints = starPoints;\n      }\n      \n      float blades = length(p * flareShape * sin(internalStarPoints * atan(p.x, p.y)));\n      \n      float comp = pow(1.-saturate(blades), ( anamorphic ? 100. : 12.));\n      comp += saturate(expgrad-0.9) * 3.;\n      comp = pow(comp * expgrad, 8. + (1.-intensity) * 5.);\n      \n      if(flareSpeed > 0.0){\n        return vec3(comp) * colgrad;\n      } else{\n        return vec3(comp) * flareSize * 15.;\n      }\n    }\n\n    float dist(vec3 a, vec3 b) { return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z); }\n\n    vec3 saturate(vec3 x)\n    {\n      return clamp(x, vec3(0.0), vec3(1.0));\n    }\n\n    // Based on https://www.shadertoy.com/view/XtKfRV\n    float glare(vec2 uv, vec2 pos, float size)\n    {\n      vec2 main;\n\n      if(animated){\n        main = rotateUV(uv-pos, time * 0.1);      \n      } else{\n        main = uv-pos;     \n      }\n      \n      float ang = atan(main.y, main.x) * (anamorphic ? 1.0 : starPoints);\n      float dist = length(main); \n      dist = pow(dist, .9);\n      \n      float f0 = 1.0/(length(uv-pos)*(1.0/size*16.0)+.2);\n\n      return f0+f0*(sin((ang))*.2 +.3);\n    }\n\n    float sdHex(vec2 p){\n      p = abs(p);\n      vec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);\n      return dot(step(q.xy,q.yx), 1.0-q.yx);\n    }\n\n    //Based on https://www.shadertoy.com/view/dllSRX\n    float fpow(float x, float k){\n      return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n    }\n\n    vec3 renderhex(vec2 uv, vec2 p, float s, vec3 col){\n      uv -= p;\n      if (abs(uv.x) < 0.2*s && abs(uv.y) < 0.2*s){\n          return mix(vec3(0),mix(vec3(0),col,0.1 + fpow(length(uv/s),0.1)*10.0),smoothstep(0.0,0.1,sdHex(uv*20.0/s)));\n      }\n      return vec3(0);\n    }\n\n    // Based on https://www.shadertoy.com/view/4sX3Rs\n    vec3 LensFlare(vec2 uv, vec2 pos)\n    {\n      vec2 main = uv-pos;\n      vec2 uvd = uv*(length(uv));\n      \n      float ang = atan(main.x,main.y);\n      \n      float f0 = .3/(length(uv-pos)*16.0+1.0);\n      \n      f0 = f0*(sin(noise(sin(ang*3.9-(animated ? time : 0.0) * 0.3) * starPoints))*.2 );\n      \n      float f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n      float f2 = max(.9/(10.0+32.0*pow(length(uvd+0.99*pos),2.0)),.0)*0.35;\n      float f22 = max(.9/(11.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*0.23;\n      float f23 = max(.9/(12.0+32.0*pow(length(uvd+0.95*pos),2.0)),.0)*0.6;\n      \n      vec2 uvx = mix(uv,uvd, 0.1);\n      \n      float f4 = max(0.01-pow(length(uvx+0.4*pos),2.9),.0)*4.02;\n      float f42 = max(0.0-pow(length(uvx+0.45*pos),2.9),.0)*4.1;\n      float f43 = max(0.01-pow(length(uvx+0.5*pos),2.9),.0)*4.6;\n      \n      uvx = mix(uv,uvd,-.4);\n      \n      float f5 = max(0.01-pow(length(uvx+0.1*pos),5.5),.0)*2.0;\n      float f52 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n      float f53 = max(0.01-pow(length(uvx+0.1*pos),5.5),.0)*2.0;\n      \n      uvx = mix(uv,uvd, 2.1);\n      \n      float f6 = max(0.01-pow(length(uvx-0.3*pos),1.61),.0)*3.159;\n      float f62 = max(0.01-pow(length(uvx-0.325*pos),1.614),.0)*3.14;\n      float f63 = max(0.01-pow(length(uvx-0.389*pos),1.623),.0)*3.12;\n      \n      vec3 c = vec3(glare(uv,pos, glareSize));\n\n      vec2 prot;\n\n      if(animated){\n        prot = rotateUV(uv - pos, (time * 0.1));  \n      } else if(anamorphic){\n        prot = rotateUV(uv - pos, 1.570796);     \n      } else {\n        prot = uv - pos;\n      }\n\n      c += drawflare(prot, (anamorphic ? flareSize * 10. : flareSize), 0.1, time, 1);\n      \n      c.r+=f1+f2+f4+f5+f6; c.g+=f1+f22+f42+f52+f62; c.b+=f1+f23+f43+f53+f63;\n      c = c*1.3 * vec3(length(uvd)+.09);\n      c+=vec3(f0);\n      \n      return c;\n    }\n\n    vec3 cc(vec3 color, float factor,float factor2)\n    {\n      float w = color.x+color.y+color.z;\n      return mix(color,vec3(w)*factor,w*factor2);\n    }    \n\n    float rnd(vec2 p)\n    {\n      float f = fract(sin(dot(p, vec2(12.1234, 72.8392) )*45123.2));\n      return f;   \n    }\n\n    float rnd(float w)\n    {\n      float f = fract(sin(w)*1000.);\n      return f;   \n    }\n\n    float regShape(vec2 p, int N)\n    {\n      float f;\n      \n      float a=atan(p.x,p.y)+.2;\n      float b=6.28319/float(N);\n      f=smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy)* 2.0  -ghostScale);\n          \n      return f;\n    }\n\n    // Based on https://www.shadertoy.com/view/Xlc3D2\n    vec3 circle(vec2 p, float size, float decay, vec3 color, vec3 color2, float dist, vec2 position)\n    {\n      float l = length(p + position*(dist*2.))+size/2.;\n      float l2 = length(p + position*(dist*4.))+size/3.;\n      \n      float c = max(0.01-pow(length(p + position*dist), size*ghostScale), 0.0)*10.;\n      float c1 = max(0.001-pow(l-0.3, 1./40.)+sin(l*20.), 0.0)*3.;\n      float c2 =  max(0.09/pow(length(p-position*dist/.5)*1., .95), 0.0)/20.;\n      float s = max(0.02-pow(regShape(p*5. + position*dist*5. + decay, 6) , 1.), 0.0)*1.5;\n      \n      color = cos(vec3(0.44, .24, .2)*16. + dist/8.)*0.5+.5;\n      vec3 f = c*color;\n      f += c1*color;\n      f += c2*color;  \n      f +=  s*color;\n      return f;\n    }\n\n    vec4 getLensColor(float x){\n      return vec4(vec3(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(vec3(0., 0., 0.),\n        vec3(0., 0., 0.), smoothstep(0.0, 0.063, x)),\n        vec3(0., 0., 0.), smoothstep(0.063, 0.125, x)),\n        vec3(0.0, 0., 0.), smoothstep(0.125, 0.188, x)),\n        vec3(0.188, 0.131, 0.116), smoothstep(0.188, 0.227, x)),\n        vec3(0.31, 0.204, 0.537), smoothstep(0.227, 0.251, x)),\n        vec3(0.192, 0.106, 0.286), smoothstep(0.251, 0.314, x)),\n        vec3(0.102, 0.008, 0.341), smoothstep(0.314, 0.392, x)),\n        vec3(0.086, 0.0, 0.141), smoothstep(0.392, 0.502, x)),\n        vec3(1.0, 0.31, 0.0), smoothstep(0.502, 0.604, x)),\n        vec3(.1, 0.1, 0.1), smoothstep(0.604, 0.643, x)),\n        vec3(1.0, 0.929, 0.0), smoothstep(0.643, 0.761, x)),\n        vec3(1.0, 0.086, 0.424), smoothstep(0.761, 0.847, x)),\n        vec3(1.0, 0.49, 0.0), smoothstep(0.847, 0.89, x)),\n        vec3(0.945, 0.275, 0.475), smoothstep(0.89, 0.941, x)),\n        vec3(0.251, 0.275, 0.796), smoothstep(0.941, 1.0, x))),\n      1.0);\n    }\n\n    float dirtNoise(vec2 p){\n      vec2 f = fract(p);\n      f = (f * f) * (3.0 - (2.0 * f));    \n      float n = dot(floor(p), vec2(1.0, 157.0));\n      vec4 a = fract(sin(vec4(n + 0.0, n + 1.0, n + 157.0, n + 158.0)) * 43758.5453123);\n      return mix(mix(a.x, a.y, f.x), mix(a.z, a.w, f.x), f.y);\n    } \n\n    float fbm(vec2 p){\n      const mat2 m = mat2(0.80, -0.60, 0.60, 0.80);\n      float f = 0.0;\n      f += 0.5000*dirtNoise(p); p = m*p*2.02;\n      f += 0.2500*dirtNoise(p); p = m*p*2.03;\n      f += 0.1250*dirtNoise(p); p = m*p*2.01;\n      f += 0.0625*dirtNoise(p);\n      return f/0.9375;\n    }\n\n    vec4 getLensStar(vec2 p){\n      vec2 pp = (p - vec2(0.5)) * 2.0;\n      float a = atan(pp.y, pp.x);\n      vec4 cp = vec4(sin(a * 1.0), length(pp), sin(a * 13.0), sin(a * 53.0));\n      float d = sin(clamp(pow(length(vec2(0.5) - p) * 0.5 + haloScale /2., 5.0), 0.0, 1.0) * 3.14159);\n      vec3 c = vec3(d) * vec3(fbm(cp.xy * 16.0) * fbm(cp.zw * 9.0) * max(max(max(max(0.5, sin(a * 1.0)), sin(a * 3.0) * 0.8), sin(a * 7.0) * 0.8), sin(a * 9.0) * 10.6));\n      c *= vec3(mix(2.0, (sin(length(pp.xy) * 256.0) * 0.5) + 0.5, sin((clamp((length(pp.xy) - 0.875) / 0.1, 0.0, 1.0) + 0.0) * 2.0 * 3.14159) * 1.5) + 0.5) * 0.3275;\n      return vec4(vec3(c * 1.0), d);\t\n    }\n\n    vec4 getLensDirt(vec2 p){\n      p.xy += vec2(fbm(p.yx * 3.0), fbm(p.yx * 2.0)) * 0.0825;\n      vec3 o = vec3(mix(0.125, 0.25, max(max(smoothstep(0.1, 0.0, length(p - vec2(0.25))),\n                                            smoothstep(0.4, 0.0, length(p - vec2(0.75)))),\n                                            smoothstep(0.8, 0.0, length(p - vec2(0.875, 0.125))))));\n      o += vec3(max(fbm(p * 1.0) - 0.5, 0.0)) * 0.5;\n      o += vec3(max(fbm(p * 2.0) - 0.5, 0.0)) * 0.5;\n      o += vec3(max(fbm(p * 4.0) - 0.5, 0.0)) * 0.25;\n      o += vec3(max(fbm(p * 8.0) - 0.75, 0.0)) * 1.0;\n      o += vec3(max(fbm(p * 16.0) - 0.75, 0.0)) * 0.75;\n      o += vec3(max(fbm(p * 64.0) - 0.75, 0.0)) * 0.5;\n      return vec4(clamp(o, vec3(0.15), vec3(1.0)), 1.0);\t\n    }\n\n    vec4 textureLimited(sampler2D tex, vec2 texCoord){\n      if(((texCoord.x < 0.) || (texCoord.y < 0.)) || ((texCoord.x > 1.) || (texCoord.y > 1.))){\n        return vec4(0.0);\n      }else{\n        return texture(tex, texCoord); \n      }\n    }\n\n    vec4 textureDistorted(sampler2D tex, vec2 texCoord, vec2 direction, vec3 distortion) {\n      return vec4(textureLimited(tex, (texCoord + (direction * distortion.r))).r,\n                  textureLimited(tex, (texCoord + (direction * distortion.g))).g,\n                  textureLimited(tex, (texCoord + (direction * distortion.b))).b,\n                  1.0);\n    }\n\n    // Based on https://www.shadertoy.com/view/4sK3W3\n    vec4 getStartBurst(){\n      vec2 aspectTexCoord = vec2(1.0) - (((vTexCoord - vec2(0.5)) * vec2(1.0)) + vec2(0.5)); \n      vec2 texCoord = vec2(1.0) - vTexCoord; \n      vec2 ghostVec = (vec2(0.5) - texCoord) * 0.3 - lensPosition;\n      vec2 ghostVecAspectNormalized = normalize(ghostVec * vec2(1.0)) * vec2(1.0);\n      vec2 haloVec = normalize(ghostVec) * 0.6;\n      vec2 haloVecAspectNormalized = ghostVecAspectNormalized * 0.6;\n      vec2 texelSize = vec2(1.0) / vec2(screenRes.xy);\n      vec3 distortion = vec3(-(texelSize.x * 1.5), 0.2, texelSize.x * 1.5);\n      vec4 c = vec4(0.0);\n      for (int i = 0; i < 8; i++) {\n        vec2 offset = texCoord + (ghostVec * float(i));\n        c += textureDistorted(lensDirtTexture, offset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - offset) / length(vec2(0.5)))), 10.0);\n      }                       \n      vec2 haloOffset = texCoord + haloVecAspectNormalized; \n      return (c * getLensColor((length(vec2(0.5) - aspectTexCoord) / length(vec2(haloScale))))) + \n            (textureDistorted(lensDirtTexture, haloOffset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - haloOffset) / length(vec2(0.5)))), 10.0));\n    } \n\n    void mainImage(vec4 inputColor, vec2 uv, out vec4 outputColor)\n    {\n      vec2 myUV = uv -0.5;\n      myUV.y *= screenRes.y/screenRes.x;\n      vec2 finalLensPosition = lensPosition * 0.5;\n      finalLensPosition.y *= screenRes.y/screenRes.x;\n      \n      //First Lens flare pass\n      vec3 finalColor = LensFlare(myUV, finalLensPosition) * 20.0 * colorGain / 256.;\n\n      //Aditional streaks\n      if(aditionalStreaks){\n        vec3 circColor = vec3(0.9, 0.2, 0.1);\n        vec3 circColor2 = vec3(0.3, 0.1, 0.9);\n\n        for(float i=0.;i<10.;i++){\n          finalColor += circle(myUV, pow(rnd(i*2000.)*2.8, .1)+1.41, 0.0, circColor+i , circColor2+i, rnd(i*20.)*3.+0.2-.5, lensPosition);\n        }\n      }\n\n      //Alternative ghosts\n      if(secondaryGhosts){\n        vec3 altGhosts = vec3(0);\n        altGhosts += renderhex(myUV, -lensPosition*0.25, ghostScale * 1.4, vec3(0.25,0.35,0));\n        altGhosts += renderhex(myUV, lensPosition*0.25, ghostScale * 0.5, vec3(1,0.5,0.5));\n        altGhosts += renderhex(myUV, lensPosition*0.1, ghostScale * 1.6, vec3(1,1,1));\n        altGhosts += renderhex(myUV, lensPosition*1.8, ghostScale * 2.0, vec3(0,0.5,0.75));\n        altGhosts += renderhex(myUV, lensPosition*1.25, ghostScale * 0.8, vec3(1,1,0.5));\n        altGhosts += renderhex(myUV, -lensPosition*1.25, ghostScale * 5.0, vec3(0.5,0.5,0.25));\n        \n        //Circular ghosts\n        altGhosts += fpow(1.0 - abs(distance(lensPosition*0.8,myUV) - 0.7),0.985)*colorGain / 2100.;\n        finalColor += altGhosts;\n      }\n      \n\n      //Starburst                     \n      if(starBurst){\n        vTexCoord = myUV + 0.5;\n        vec4 lensMod = getLensDirt(myUV);\n        float tooBright = 1.0 - (clamp(0.5, 0.0, 0.5) * 2.0); \n        float tooDark = clamp(0.5 - 0.5, 0.0, 0.5) * 2.0;\n        lensMod += mix(lensMod, pow(lensMod * 2.0, vec4(2.0)) * 0.5, tooBright);\n        float lensStarRotationAngle = ((myUV.x + myUV.y)) * (1.0 / 6.0);\n        vec2 lensStarTexCoord = (mat2(cos(lensStarRotationAngle), -sin(lensStarRotationAngle), sin(lensStarRotationAngle), cos(lensStarRotationAngle)) * vTexCoord);\n        lensMod += getLensStar(lensStarTexCoord) * 2.;\n        \n        finalColor += clamp((lensMod.rgb * getStartBurst().rgb ), 0.01, 1.0);\n      }\n\n      //Final composed output\n      if(enabled){\n        outputColor = vec4(mix(finalColor, vec3(.0), opacity) + inputColor.rgb, inputColor.a);\n      } else {\n        outputColor = vec4(inputColor);\n      }\n    }\n  `\n  };\nclass fe extends W {\n  constructor({\n    blendFunction: t,\n    enabled: o,\n    glareSize: r,\n    lensPosition: a,\n    screenRes: n,\n    starPoints: i,\n    flareSize: s,\n    flareSpeed: l,\n    flareShape: p,\n    animated: _,\n    anamorphic: S,\n    colorGain: g,\n    lensDirtTexture: d,\n    haloScale: m,\n    secondaryGhosts: v,\n    aditionalStreaks: x,\n    ghostScale: f,\n    opacity: u,\n    starBurst: c\n  }) {\n    super(\"LensFlareEffect\", _t.fragmentShader, {\n      blendFunction: t,\n      uniforms: /*@__PURE__*/new Map([[\"enabled\", new h.Uniform(o)], [\"glareSize\", new h.Uniform(r)], [\"lensPosition\", new h.Uniform(a)], [\"time\", new h.Uniform(0)], [\"screenRes\", new h.Uniform(n)], [\"starPoints\", new h.Uniform(i)], [\"flareSize\", new h.Uniform(s)], [\"flareSpeed\", new h.Uniform(l)], [\"flareShape\", new h.Uniform(p)], [\"animated\", new h.Uniform(_)], [\"anamorphic\", new h.Uniform(S)], [\"colorGain\", new h.Uniform(g)], [\"lensDirtTexture\", new h.Uniform(d)], [\"haloScale\", new h.Uniform(m)], [\"secondaryGhosts\", new h.Uniform(v)], [\"aditionalStreaks\", new h.Uniform(x)], [\"ghostScale\", new h.Uniform(f)], [\"starBurst\", new h.Uniform(c)], [\"opacity\", new h.Uniform(u)]])\n    });\n  }\n  update(t, o, r) {\n    const a = this.uniforms.get(\"time\");\n    a && (a.value += r);\n  }\n}\nconst xt = /*@__PURE__*/P(fe),\n  gt = ({\n    smoothTime: e = .07,\n    blendFunction: t = 23,\n    enabled: o = !0,\n    glareSize: r = .2,\n    lensPosition: a = new h.Vector3(-25, 6, -60),\n    screenRes: n = new h.Vector2(0, 0),\n    starPoints: i = 6,\n    flareSize: s = .01,\n    flareSpeed: l = .01,\n    flareShape: p = .01,\n    animated: _ = !0,\n    anamorphic: S = !1,\n    colorGain: g = new h.Color(20, 20, 20),\n    lensDirtTexture: d = null,\n    haloScale: m = .5,\n    secondaryGhosts: v = !0,\n    aditionalStreaks: x = !0,\n    ghostScale: f = 0,\n    opacity: u = 1,\n    starBurst: c = !1\n  }) => {\n    const U = V(({\n        viewport: T\n      }) => T),\n      b = V(({\n        raycaster: T\n      }) => T),\n      {\n        scene: F,\n        camera: X\n      } = M(D),\n      [C] = j(() => new h.Vector2()),\n      [R] = j(() => new h.Vector3()),\n      E = O(null);\n    return J((T, N) => {\n      if (!E?.current) return;\n      const q = E.current.uniforms.get(\"lensPosition\"),\n        $ = E.current.uniforms.get(\"opacity\");\n      if (!q || !$) return;\n      let G = 1;\n      if (R.copy(a).project(X), R.z > 1) return;\n      q.value.x = R.x, q.value.y = R.y, C.x = R.x, C.y = R.y, b.setFromCamera(C, X);\n      const ve = b.intersectObjects(F.children, !0),\n        {\n          object: I\n        } = ve[0] || {};\n      I && (I.userData?.lensflare === \"no-occlusion\" ? G = 0 : I instanceof h.Mesh && (I.material.uniforms?._transmission?.value > .2 || I.material._transmission && I.material._transmission > .2 ? G = .2 : I.material.transparent && (G = I.material.opacity))), se.damp($, \"value\", G, e, N);\n    }), A(() => {\n      if (!E?.current) return;\n      const T = E.current.uniforms.get(\"screenRes\");\n      T && (T.value.x = U.width, T.value.y = U.height);\n    }, [U]), /*@__PURE__*/w(xt, {\n      ref: E,\n      blendFunction: t,\n      enabled: o,\n      glareSize: r,\n      lensPosition: a,\n      screenRes: n,\n      starPoints: i,\n      flareSize: s,\n      flareSpeed: l,\n      flareShape: p,\n      animated: _,\n      anamorphic: S,\n      colorGain: g,\n      lensDirtTexture: d,\n      haloScale: m,\n      secondaryGhosts: v,\n      aditionalStreaks: x,\n      ghostScale: f,\n      opacity: u,\n      starBurst: c\n    });\n  },\n  wt = /*@__PURE__*/P(Ie, {\n    blendFunction: 0\n  }),\n  St = /*@__PURE__*/P(Le),\n  yt = /*@__PURE__*/P(Ne),\n  Pt = /*@__PURE__*/B(function ({\n    blendFunction: e = 23\n  }, t) {\n    const o = z(() => new je(e), [e]);\n    return /*@__PURE__*/w(\"primitive\", {\n      ref: t,\n      object: o,\n      dispose: null\n    });\n  }),\n  bt = /*@__PURE__*/P(Oe),\n  Et = /*@__PURE__*/P(We),\n  Rt = /*@__PURE__*/P(Xe),\n  Ut = /*@__PURE__*/B(function ({\n    active: e = !0,\n    ...t\n  }, o) {\n    const r = V(p => p.invalidate),\n      a = Z(t, \"delay\"),\n      n = Z(t, \"duration\"),\n      i = Z(t, \"strength\"),\n      s = Z(t, \"chromaticAberrationOffset\"),\n      l = z(() => new qe({\n        ...t,\n        delay: a,\n        duration: n,\n        strength: i,\n        chromaticAberrationOffset: s\n      }), [a, n, t, i, s]);\n    return L(() => {\n      l.mode = e ? t.mode || ne.SPORADIC : ne.DISABLED, r();\n    }, [e, l, r, t.mode]), A(() => () => {\n      l.dispose?.();\n    }, [l]), /*@__PURE__*/w(\"primitive\", {\n      ref: o,\n      object: l,\n      dispose: null\n    });\n  }),\n  Ct = /*@__PURE__*/B(function (e, t) {\n    const {\n        camera: o\n      } = M(D),\n      r = z(() => new He(o, k(e.sun), e), [o, e]);\n    return L(() => void (r.lightSource = k(e.sun)), [r, e.sun]), /*@__PURE__*/w(\"primitive\", {\n      ref: t,\n      object: r,\n      dispose: null\n    });\n  }),\n  zt = /*@__PURE__*/B(function ({\n    size: e,\n    ...t\n  }, o) {\n    const r = V(n => n.invalidate),\n      a = z(() => new Ze(t), [t]);\n    return L(() => {\n      e && a.setSize(e.width, e.height), r();\n    }, [a, e, r]), /*@__PURE__*/w(\"primitive\", {\n      ref: o,\n      object: a,\n      dispose: null\n    });\n  }),\n  Tt = /*@__PURE__*/P($e),\n  At = /*@__PURE__*/P(Ke, {\n    blendFunction: 5\n  }),\n  Bt = /*@__PURE__*/B(function ({\n    selection: e = [],\n    selectionLayer: t = 10,\n    blendFunction: o,\n    patternTexture: r,\n    edgeStrength: a,\n    pulseSpeed: n,\n    visibleEdgeColor: i,\n    hiddenEdgeColor: s,\n    width: l,\n    height: p,\n    kernelSize: _,\n    blur: S,\n    xRay: g,\n    ...d\n  }, m) {\n    const v = V(U => U.invalidate),\n      {\n        scene: x,\n        camera: f\n      } = M(D),\n      u = z(() => new Ye(x, f, {\n        blendFunction: o,\n        patternTexture: r,\n        edgeStrength: a,\n        pulseSpeed: n,\n        visibleEdgeColor: i,\n        hiddenEdgeColor: s,\n        width: l,\n        height: p,\n        kernelSize: _,\n        blur: S,\n        xRay: g,\n        ...d\n      }), [o, S, f, a, p, s, _, r, n, x, i, l, g]),\n      c = M(H);\n    return A(() => {\n      if (!c && e) return u.selection.set(Array.isArray(e) ? e.map(k) : [k(e)]), v(), () => {\n        u.selection.clear(), v();\n      };\n    }, [u, e, c, v]), A(() => {\n      u.selectionLayer = t, v();\n    }, [u, v, t]), O(void 0), A(() => {\n      if (c && c.enabled && c.selected?.length) return u.selection.set(c.selected), v(), () => {\n        u.selection.clear(), v();\n      };\n    }, [c, u.selection, v]), A(() => () => {\n      u.dispose();\n    }, [u]), /*@__PURE__*/w(\"primitive\", {\n      ref: m,\n      object: u\n    });\n  }),\n  Vt = /*@__PURE__*/B(function ({\n    granularity: e = 5\n  }, t) {\n    const o = z(() => new Je(e), [e]);\n    return /*@__PURE__*/w(\"primitive\", {\n      ref: t,\n      object: o,\n      dispose: null\n    });\n  }),\n  Ft = /*@__PURE__*/P(Qe, {\n    blendFunction: 24,\n    density: 1.25\n  }),\n  Mt = (e, t) => e.layers.enable(t.selection.layer),\n  Dt = (e, t) => e.layers.disable(t.selection.layer),\n  kt = /*@__PURE__*/B(function ({\n    selection: e = [],\n    selectionLayer: t = 10,\n    lights: o = [],\n    inverted: r = !1,\n    ignoreBackground: a = !1,\n    luminanceThreshold: n,\n    luminanceSmoothing: i,\n    intensity: s,\n    width: l,\n    height: p,\n    kernelSize: _,\n    mipmapBlur: S,\n    ...g\n  }, d) {\n    o.length === 0 && console.warn(\"SelectiveBloom requires lights to work.\");\n    const m = V(c => c.invalidate),\n      {\n        scene: v,\n        camera: x\n      } = M(D),\n      f = z(() => {\n        const c = new et(v, x, {\n          blendFunction: 0,\n          luminanceThreshold: n,\n          luminanceSmoothing: i,\n          intensity: s,\n          width: l,\n          height: p,\n          kernelSize: _,\n          mipmapBlur: S,\n          ...g\n        });\n        return c.inverted = r, c.ignoreBackground = a, c;\n      }, [v, x, n, i, s, l, p, _, S, r, a, g]),\n      u = M(H);\n    return A(() => {\n      if (!u && e) return f.selection.set(Array.isArray(e) ? e.map(k) : [k(e)]), m(), () => {\n        f.selection.clear(), m();\n      };\n    }, [f, e, u, m]), A(() => {\n      f.selection.layer = t, m();\n    }, [f, m, t]), A(() => {\n      if (o && o.length > 0) return o.forEach(c => Mt(k(c), f)), m(), () => {\n        o.forEach(c => Dt(k(c), f)), m();\n      };\n    }, [f, m, o, t]), A(() => {\n      if (u && u.enabled && u.selected?.length) return f.selection.set(u.selected), m(), () => {\n        f.selection.clear(), m();\n      };\n    }, [u, f.selection, m]), /*@__PURE__*/w(\"primitive\", {\n      ref: d,\n      object: f,\n      dispose: null\n    });\n  }),\n  Gt = /*@__PURE__*/P(tt),\n  It = /*@__PURE__*/B(function (e, t) {\n    const {\n        camera: o,\n        normalPass: r,\n        downSamplingPass: a,\n        resolutionScale: n\n      } = M(D),\n      i = z(() => r === null && a === null ? (console.error(\"Please enable the NormalPass in the EffectComposer in order to use SSAO.\"), {}) : new ot(o, r && !a ? r.texture : null, {\n        blendFunction: 21,\n        samples: 30,\n        rings: 4,\n        distanceThreshold: 1,\n        distanceFalloff: 0,\n        rangeThreshold: .5,\n        rangeFalloff: .1,\n        luminanceInfluence: .9,\n        radius: 20,\n        bias: .5,\n        intensity: 1,\n        color: void 0,\n        normalDepthBuffer: a ? a.texture : null,\n        resolutionScale: n ?? 1,\n        depthAwareUpsampling: !0,\n        ...e\n      }), [o, a, r, n]);\n    return /*@__PURE__*/w(\"primitive\", {\n      ref: t,\n      object: i,\n      dispose: null\n    });\n  }),\n  Lt = /*@__PURE__*/P(at),\n  Nt = /*@__PURE__*/P(rt),\n  jt = {\n    fragmentShader: `\n    uniform int rampType;\n\n    uniform vec2 rampStart;\n    uniform vec2 rampEnd;\n\n    uniform vec4 startColor;\n    uniform vec4 endColor;\n\n    uniform float rampBias;\n    uniform float rampGain;\n\n    uniform bool rampMask;\n    uniform bool rampInvert;\n\n    float getBias(float time, float bias) {\n      return time / (((1.0 / bias) - 2.0) * (1.0 - time) + 1.0);\n    }\n\n    float getGain(float time, float gain) {\n      if (time < 0.5)\n        return getBias(time * 2.0, gain) / 2.0;\n      else\n        return getBias(time * 2.0 - 1.0, 1.0 - gain) / 2.0 + 0.5;\n    }\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n      vec2 centerPixel = uv * resolution;\n      vec2 startPixel = rampStart * resolution;\n      vec2 endPixel = rampEnd * resolution;\n\n      float rampAlpha;\n\n      if (rampType == 1) {\n        vec2 fuv = centerPixel / resolution.y;\n        vec2 suv = startPixel / resolution.y;\n        vec2 euv = endPixel / resolution.y;\n\n        float radius = length(suv - euv);\n        float falloff = length(fuv - suv);\n        rampAlpha = smoothstep(0.0, radius, falloff);\n      } else {\n        float radius = length(startPixel - endPixel);\n        vec2 direction = normalize(vec2(endPixel.x - startPixel.x, -(startPixel.y - endPixel.y)));\n\n        float fade = dot(centerPixel - startPixel, direction);\n        if (rampType == 2) fade = abs(fade);\n\n        rampAlpha = smoothstep(0.0, 1.0, fade / radius);\n      }\n\n      rampAlpha = abs((rampInvert ? 1.0 : 0.0) - getBias(rampAlpha, rampBias) * getGain(rampAlpha, rampGain));\n\n      if (rampMask) {\n        vec4 inputBuff = texture2D(inputBuffer, uv);\n        outputColor = mix(inputBuff, inputColor, rampAlpha);\n      } else {\n        outputColor = mix(startColor, endColor, rampAlpha);\n      }\n    }\n  `\n  };\nvar ue = /*@__PURE__*/(e => (e[e.Linear = 0] = \"Linear\", e[e.Radial = 1] = \"Radial\", e[e.MirroredLinear = 2] = \"MirroredLinear\", e))(ue || {});\nclass pe extends W {\n  constructor({\n    rampType: t = 0,\n    rampStart: o = [.5, .5],\n    rampEnd: r = [1, 1],\n    startColor: a = [0, 0, 0, 1],\n    endColor: n = [1, 1, 1, 1],\n    rampBias: i = .5,\n    rampGain: s = .5,\n    rampMask: l = !1,\n    rampInvert: p = !1,\n    ..._\n  } = {}) {\n    super(\"RampEffect\", jt.fragmentShader, {\n      ..._,\n      uniforms: /*@__PURE__*/new Map([[\"rampType\", new y(t)], [\"rampStart\", new y(o)], [\"rampEnd\", new y(r)], [\"startColor\", new y(a)], [\"endColor\", new y(n)], [\"rampBias\", new y(i)], [\"rampGain\", new y(s)], [\"rampMask\", new y(l)], [\"rampInvert\", new y(p)]])\n    });\n  }\n}\nconst Ot = /*@__PURE__*/P(pe),\n  Wt = /*@__PURE__*/B(function ({\n    textureSrc: e,\n    texture: t,\n    opacity: o = 1,\n    ...r\n  }, a) {\n    const n = Ue(we, e);\n    L(() => {\n      n.colorSpace = Se, n.wrapS = n.wrapT = Y;\n    }, [n]);\n    const i = z(() => new nt({\n      ...r,\n      texture: n || t\n    }), [r, n, t]);\n    return /*@__PURE__*/w(\"primitive\", {\n      ref: a,\n      object: i,\n      \"blendMode-opacity-value\": o,\n      dispose: null\n    });\n  }),\n  Xt = /*@__PURE__*/P(st),\n  qt = /*@__PURE__*/P(it),\n  Ht = /*@__PURE__*/P(lt),\n  Zt = /*@__PURE__*/B(function ({\n    lut: e,\n    tetrahedralInterpolation: t,\n    ...o\n  }, r) {\n    const a = z(() => new ct(e, o), [e, o]),\n      n = V(i => i.invalidate);\n    return L(() => {\n      t && (a.tetrahedralInterpolation = t), e && (a.lut = e), n();\n    }, [a, n, e, t]), /*@__PURE__*/w(\"primitive\", {\n      ref: r,\n      object: a,\n      dispose: null\n    });\n  }),\n  $t = /*@__PURE__*/P(ft, {\n    blendFunction: 0\n  }),\n  Kt = {\n    fragmentShader: `\n\n    // original shader by Evan Wallace\n\n    #define MAX_ITERATIONS 100\n\n    uniform float blur;\n    uniform float taper;\n    uniform vec2 start;\n    uniform vec2 end;\n    uniform vec2 direction;\n    uniform int samples;\n\n    float random(vec3 scale, float seed) {\n        /* use the fragment position for a different seed per-pixel */\n        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n    }\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        vec4 color = vec4(0.0);\n        float total = 0.0;\n        vec2 startPixel = vec2(start.x * resolution.x, start.y * resolution.y);\n        vec2 endPixel = vec2(end.x * resolution.x, end.y * resolution.y);\n        float f_samples = float(samples);\n        float half_samples = f_samples / 2.0;\n\n        // use screen diagonal to normalize blur radii\n        float maxScreenDistance = distance(vec2(0.0), resolution); // diagonal distance\n        float gradientRadius = taper * (maxScreenDistance);\n        float blurRadius = blur * (maxScreenDistance / 16.0);\n\n        /* randomize the lookup values to hide the fixed number of samples */\n        float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n        vec2 normal = normalize(vec2(startPixel.y - endPixel.y, endPixel.x - startPixel.x));\n        float radius = smoothstep(0.0, 1.0, abs(dot(uv * resolution - startPixel, normal)) / gradientRadius) * blurRadius;\n\n        #pragma unroll_loop_start\n        for (int i = 0; i <= MAX_ITERATIONS; i++) {\n            if (i >= samples) { break; } // return early if over sample count\n            float f_i = float(i);\n            float s_i = -half_samples + f_i;\n            float percent = (s_i + offset - 0.5) / half_samples;\n            float weight = 1.0 - abs(percent);\n            vec4 sample_i = texture2D(inputBuffer, uv + normalize(direction) / resolution * percent * radius);\n            /* switch to pre-multiplied alpha to correctly blur transparent images */\n            sample_i.rgb *= sample_i.a;\n            color += sample_i * weight;\n            total += weight;\n        }\n        #pragma unroll_loop_end\n\n        outputColor = color / total;\n\n        /* switch back from pre-multiplied alpha */\n        outputColor.rgb /= outputColor.a + 0.00001;\n    }\n    `\n  };\nclass me extends W {\n  constructor({\n    blendFunction: t = 23,\n    blur: o = .15,\n    taper: r = .5,\n    start: a = [.5, 0],\n    end: n = [.5, 1],\n    samples: i = 10,\n    direction: s = [1, 1]\n  } = {}) {\n    super(\"TiltShiftEffect\", Kt.fragmentShader, {\n      blendFunction: t,\n      attributes: 2,\n      uniforms: /*@__PURE__*/new Map([[\"blur\", new y(o)], [\"taper\", new y(r)], [\"start\", new y(a)], [\"end\", new y(n)], [\"samples\", new y(i)], [\"direction\", new y(s)]])\n    });\n  }\n}\nconst Yt = /*@__PURE__*/P(me, {\n    blendFunction: 23\n  }),\n  Jt = `\nuniform sampler2D uCharacters;\nuniform float uCharactersCount;\nuniform float uCellSize;\nuniform bool uInvert;\nuniform vec3 uColor;\n\nconst vec2 SIZE = vec2(16.);\n\nvec3 greyscale(vec3 color, float strength) {\n    float g = dot(color, vec3(0.299, 0.587, 0.114));\n    return mix(color, vec3(g), strength);\n}\n\nvec3 greyscale(vec3 color) {\n    return greyscale(color, 1.0);\n}\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n    vec2 cell = resolution / uCellSize;\n    vec2 grid = 1.0 / cell;\n    vec2 pixelizedUV = grid * (0.5 + floor(uv / grid));\n    vec4 pixelized = texture2D(inputBuffer, pixelizedUV);\n    float greyscaled = greyscale(pixelized.rgb).r;\n\n    if (uInvert) {\n        greyscaled = 1.0 - greyscaled;\n    }\n\n    float characterIndex = floor((uCharactersCount - 1.0) * greyscaled);\n    vec2 characterPosition = vec2(mod(characterIndex, SIZE.x), floor(characterIndex / SIZE.y));\n    vec2 offset = vec2(characterPosition.x, -characterPosition.y) / SIZE;\n    vec2 charUV = mod(uv * (cell / SIZE), 1.0 / SIZE) - vec2(0., 1.0 / SIZE) + offset;\n    vec4 asciiCharacter = texture2D(uCharacters, charUV);\n\n    asciiCharacter.rgb = uColor * asciiCharacter.r;\n    asciiCharacter.a = pixelized.a;\n    outputColor = asciiCharacter;\n}\n`;\nclass Qt extends W {\n  constructor({\n    font: t = \"arial\",\n    characters: o = \" .:,'-^=*+?!|0#X%WM@\",\n    fontSize: r = 54,\n    cellSize: a = 16,\n    color: n = \"#ffffff\",\n    invert: i = !1\n  } = {}) {\n    const s = /*@__PURE__*/new Map([[\"uCharacters\", new y(new ye())], [\"uCellSize\", new y(a)], [\"uCharactersCount\", new y(o.length)], [\"uColor\", new y(new Pe(n))], [\"uInvert\", new y(i)]]);\n    super(\"ASCIIEffect\", Jt, {\n      uniforms: s\n    });\n    const l = this.uniforms.get(\"uCharacters\");\n    l && (l.value = this.createCharactersTexture(o, t, r));\n  }\n  createCharactersTexture(t, o, r) {\n    const a = document.createElement(\"canvas\"),\n      n = 1024,\n      i = 16,\n      s = n / i;\n    a.width = a.height = n;\n    const l = new be(a, void 0, Y, Y, re, re),\n      p = a.getContext(\"2d\");\n    if (!p) throw new Error(\"Context not available\");\n    p.clearRect(0, 0, n, n), p.font = `${r}px ${o}`, p.textAlign = \"center\", p.textBaseline = \"middle\", p.fillStyle = \"#fff\";\n    for (let _ = 0; _ < t.length; _++) {\n      const S = t[_],\n        g = _ % i,\n        d = Math.floor(_ / i);\n      p.fillText(S, g * s + s / 2, d * s + s / 2);\n    }\n    return l.needsUpdate = !0, l;\n  }\n}\nconst eo = /*@__PURE__*/B(({\n    font: e = \"arial\",\n    characters: t = \" .:,'-^=*+?!|0#X%WM@\",\n    fontSize: o = 54,\n    cellSize: r = 16,\n    color: a = \"#ffffff\",\n    invert: n = !1\n  }, i) => {\n    const s = z(() => new Qt({\n      characters: t,\n      font: e,\n      fontSize: o,\n      cellSize: r,\n      color: a,\n      invert: n\n    }), [t, o, r, a, n, e]);\n    return /*@__PURE__*/w(\"primitive\", {\n      ref: i,\n      object: s\n    });\n  }),\n  to = {\n    fragmentShader: `\n    uniform float factor;\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n      vec2 vUv = uv;\n      float frequency = 6.0 * factor;\n      float amplitude = 0.015 * factor;\n      float x = vUv.y * frequency + time * 0.7; \n      float y = vUv.x * frequency + time * 0.3;\n      vUv.x += cos(x + y) * amplitude * cos(y);\n      vUv.y += sin(x - y) * amplitude * cos(y);\n      vec4 rgba = texture(inputBuffer, vUv);\n      outputColor = rgba;\n    }\n  `\n  };\nclass de extends W {\n  constructor({\n    blendFunction: t = 23,\n    factor: o = 0\n  } = {}) {\n    super(\"WaterEffect\", to.fragmentShader, {\n      blendFunction: t,\n      attributes: 2,\n      uniforms: /*@__PURE__*/new Map([[\"factor\", new y(o)]])\n    });\n  }\n}\nconst oo = /*@__PURE__*/P(de, {\n    blendFunction: 23\n  }),\n  ao = /*@__PURE__*/B(({\n    halfRes: e,\n    screenSpaceRadius: t,\n    quality: o,\n    depthAwareUpsampling: r = !0,\n    aoRadius: a = 5,\n    aoSamples: n = 16,\n    denoiseSamples: i = 4,\n    denoiseRadius: s = 12,\n    distanceFalloff: l = 1,\n    intensity: p = 1,\n    color: _,\n    renderMode: S = 0\n  }, g) => {\n    const {\n        camera: d,\n        scene: m\n      } = V(),\n      v = z(() => new ut(m, d), [d, m]);\n    return L(() => {\n      Ce(v.configuration, {\n        color: _,\n        aoRadius: a,\n        distanceFalloff: l,\n        intensity: p,\n        aoSamples: n,\n        denoiseSamples: i,\n        denoiseRadius: s,\n        screenSpaceRadius: t,\n        renderMode: S,\n        halfRes: e,\n        depthAwareUpsampling: r\n      });\n    }, [t, _, a, l, p, n, i, s, S, e, r, v]), L(() => {\n      o && v.setQualityMode(o.charAt(0).toUpperCase() + o.slice(1));\n    }, [v, o]), /*@__PURE__*/w(\"primitive\", {\n      ref: g,\n      object: v\n    });\n  });\nexport { eo as ASCII, ht as Autofocus, wt as Bloom, St as BrightnessContrast, yt as ChromaticAberration, Pt as ColorAverage, bt as ColorDepth, Et as Depth, ce as DepthOfField, Rt as DotScreen, dt as EffectComposer, D as EffectComposerContext, Nt as FXAA, Ut as Glitch, Ct as GodRays, zt as Grid, Tt as HueSaturation, Zt as LUT, gt as LensFlare, fe as LensFlareEffect, ao as N8AO, At as Noise, Bt as Outline, Vt as Pixelation, Ot as Ramp, pe as RampEffect, ue as RampType, Lt as SMAA, It as SSAO, Ft as Scanline, mt as Select, pt as Selection, kt as SelectiveBloom, Gt as Sepia, Ht as ShockWave, Wt as Texture, $t as TiltShift, Yt as TiltShift2, me as TiltShiftEffect, Xt as ToneMapping, qt as Vignette, oo as WaterEffect, de as WaterEffectImpl, k as resolveRef, H as selectionContext, Z as useVector2, P as wrapEffect };","map":{"version":3,"names":["H","te","pt","children","e","enabled","t","o","r","j","a","z","selected","select","w","Provider","value","mt","O","M","A","n","i","current","traverse","s","type","push","indexOf","filter","l","includes","ref","D","ie","getAttributes","dt","he","B","camera","scene","resolutionScale","renderPriority","autoClear","depthBuffer","enableNormalPass","stencilBuffer","p","multisampling","_","frameBufferType","S","xe","g","gl","d","m","v","size","x","V","f","u","c","U","b","C","ze","addPass","Te","R","E","Ae","Be","normalBuffer","texture","setSize","width","height","J","clearStencil","render","F","L","__r3f","T","length","N","object","W","q","G","$","Ve","Fe","removePass","toneMapping","_e","X","composer","normalPass","downSamplingPass","oe","k","vt","le","WeakMap","P","blendFunction","opacity","get","name","Ee","set","ee","useMemo","args","JSON","stringify","Z","h","Vector2","ce","worldFocusDistance","worldFocusRange","focusDistance","focusRange","focalLength","bokehScale","resolutionX","resolutionY","target","depthTexture","Me","ge","setDepthTexture","packing","maskPass","maskFunction","De","MULTIPLY_RGB_SET_ALPHA","dispose","ht","mouse","debug","manual","smoothTime","pointer","ke","Ge","Vector3","ae","y","readDepth","unproject","copy","se","damp3","position","dofRef","hitpoint","update","K","Q","Re","color","transparent","depthWrite","_t","fragmentShader","fe","constructor","glareSize","lensPosition","screenRes","starPoints","flareSize","flareSpeed","flareShape","animated","anamorphic","colorGain","lensDirtTexture","haloScale","secondaryGhosts","aditionalStreaks","ghostScale","starBurst","uniforms","Map","Uniform","xt","gt","Color","viewport","raycaster","project","setFromCamera","ve","intersectObjects","I","userData","lensflare","Mesh","material","_transmission","damp","wt","Ie","St","Le","yt","Ne","Pt","je","bt","Oe","Et","We","Rt","Xe","Ut","active","invalidate","qe","delay","duration","strength","chromaticAberrationOffset","mode","ne","SPORADIC","DISABLED","Ct","He","sun","lightSource","zt","Ze","Tt","$e","At","Ke","Bt","selection","selectionLayer","patternTexture","edgeStrength","pulseSpeed","visibleEdgeColor","hiddenEdgeColor","kernelSize","blur","xRay","Ye","Array","isArray","map","clear","Vt","granularity","Je","Ft","Qe","density","Mt","effect","layers","enable","layer","Dt","disable","kt","lights","inverted","ignoreBackground","luminanceThreshold","luminanceSmoothing","intensity","mipmapBlur","console","warn","et","forEach","Gt","tt","It","error","ot","samples","rings","distanceThreshold","distanceFalloff","rangeThreshold","rangeFalloff","luminanceInfluence","radius","bias","normalDepthBuffer","depthAwareUpsampling","Lt","at","Nt","rt","jt","ue","Linear","Radial","MirroredLinear","pe","rampType","rampStart","rampEnd","startColor","endColor","rampBias","rampGain","rampMask","rampInvert","Ot","Wt","textureSrc","Ue","we","colorSpace","Se","wrapS","wrapT","Y","nt","Xt","st","qt","it","Ht","lt","Zt","lut","tetrahedralInterpolation","ct","$t","ft","Kt","me","taper","start","end","direction","attributes","Yt","Jt","Qt","font","characters","fontSize","cellSize","invert","ye","Pe","createCharactersTexture","document","createElement","be","re","getContext","Error","clearRect","textAlign","textBaseline","fillStyle","Math","floor","fillText","needsUpdate","eo","to","de","factor","oo","ao","halfRes","screenSpaceRadius","quality","aoRadius","aoSamples","denoiseSamples","denoiseRadius","renderMode","ut","Ce","configuration","setQualityMode","charAt","toUpperCase","slice","ASCII","Autofocus","Bloom","BrightnessContrast","ChromaticAberration","ColorAverage","ColorDepth","Depth","DepthOfField","DotScreen","EffectComposer","EffectComposerContext","FXAA","Glitch","GodRays","Grid","HueSaturation","LUT","LensFlare","LensFlareEffect","N8AO","Noise","Outline","Pixelation","Ramp","RampEffect","RampType","SMAA","SSAO","Scanline","Select","Selection","SelectiveBloom","Sepia","ShockWave","Texture","TiltShift","TiltShift2","TiltShiftEffect","ToneMapping","Vignette","WaterEffect","WaterEffectImpl","resolveRef","selectionContext","useVector2","wrapEffect"],"sources":["C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\Selection.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\EffectComposer.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\util.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\DepthOfField.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\Autofocus.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\LensFlare.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\Bloom.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\BrightnessContrast.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\ChromaticAberration.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\ColorAverage.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\ColorDepth.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\Depth.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\DotScreen.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\Glitch.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\GodRays.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\Grid.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\HueSaturation.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\Noise.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\Outline.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\Pixelation.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\ScanlineEffect.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\SelectiveBloom.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\Sepia.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\SSAO.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\SMAA.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\FXAA.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\Ramp.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\Texture.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\ToneMapping.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\Vignette.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\ShockWave.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\LUT.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\TiltShift.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\TiltShift2.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\ASCII.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\Water.tsx","C:\\Users\\Praanesh MB\\OneDrive\\Documents\\Kanini-Hackathon-master\\frontend\\node_modules\\@react-three\\postprocessing\\src\\effects\\N8AO.tsx"],"sourcesContent":["import * as THREE from 'three'\r\nimport React, { createContext, useState, useContext, useEffect, useRef, useMemo } from 'react'\r\nimport { type ThreeElements } from '@react-three/fiber'\r\n\r\nexport type Api = {\r\n  selected: THREE.Object3D[]\r\n  select: React.Dispatch<React.SetStateAction<THREE.Object3D[]>>\r\n  enabled: boolean\r\n}\r\nexport type SelectApi = Omit<ThreeElements['group'], 'ref'> & {\r\n  enabled?: boolean\r\n}\r\n\r\nexport const selectionContext = /* @__PURE__ */ createContext<Api | null>(null)\r\n\r\nexport function Selection({ children, enabled = true }: { enabled?: boolean; children: React.ReactNode }) {\r\n  const [selected, select] = useState<THREE.Object3D[]>([])\r\n  const value = useMemo(() => ({ selected, select, enabled }), [selected, select, enabled])\r\n  return <selectionContext.Provider value={value}>{children}</selectionContext.Provider>\r\n}\r\n\r\nexport function Select({ enabled = false, children, ...props }: SelectApi) {\r\n  const group = useRef<THREE.Group>(null!)\r\n  const api = useContext(selectionContext)\r\n  useEffect(() => {\r\n    if (api && enabled) {\r\n      let changed = false\r\n      const current: THREE.Object3D[] = []\r\n      group.current.traverse((o) => {\r\n        o.type === 'Mesh' && current.push(o)\r\n        if (api.selected.indexOf(o) === -1) changed = true\r\n      })\r\n      if (changed) {\r\n        api.select((state) => [...state, ...current])\r\n        return () => {\r\n          api.select((state) => state.filter((selected) => !current.includes(selected)))\r\n        }\r\n      }\r\n    }\r\n  }, [enabled, children, api])\r\n  return (\r\n    <group ref={group} {...props}>\r\n      {children}\r\n    </group>\r\n  )\r\n}\r\n","import type { TextureDataType, Group, Camera, Scene } from 'three'\r\nimport { HalfFloatType, NoToneMapping } from 'three'\r\nimport {\r\n  type JSX,\r\n  memo,\r\n  forwardRef,\r\n  useMemo,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  createContext,\r\n  useRef,\r\n  useImperativeHandle,\r\n} from 'react'\r\nimport { useThree, useFrame, type Instance } from '@react-three/fiber'\r\nimport {\r\n  EffectComposer as EffectComposerImpl,\r\n  RenderPass,\r\n  EffectPass,\r\n  NormalPass,\r\n  DepthDownsamplingPass,\r\n  Effect,\r\n  Pass,\r\n  EffectAttribute,\r\n} from 'postprocessing'\r\n\r\nexport const EffectComposerContext = /* @__PURE__ */ createContext<{\r\n  composer: EffectComposerImpl\r\n  normalPass: NormalPass | null\r\n  downSamplingPass: DepthDownsamplingPass | null\r\n  camera: Camera\r\n  scene: Scene\r\n  resolutionScale?: number\r\n}>(null!)\r\n\r\nexport type EffectComposerProps = {\r\n  enabled?: boolean\r\n  children: JSX.Element | JSX.Element[]\r\n  depthBuffer?: boolean\r\n  /** Only used for SSGI currently, leave it disabled for everything else unless it's needed */\r\n  enableNormalPass?: boolean\r\n  stencilBuffer?: boolean\r\n  autoClear?: boolean\r\n  resolutionScale?: number\r\n  multisampling?: number\r\n  frameBufferType?: TextureDataType\r\n  renderPriority?: number\r\n  camera?: Camera\r\n  scene?: Scene\r\n}\r\n\r\nconst isConvolution = (effect: Effect): boolean =>\r\n  (effect.getAttributes() & EffectAttribute.CONVOLUTION) === EffectAttribute.CONVOLUTION\r\n\r\nexport const EffectComposer = /* @__PURE__ */ memo(\r\n  /* @__PURE__ */ forwardRef<EffectComposerImpl, EffectComposerProps>(\r\n    (\r\n      {\r\n        children,\r\n        camera: _camera,\r\n        scene: _scene,\r\n        resolutionScale,\r\n        enabled = true,\r\n        renderPriority = 1,\r\n        autoClear = true,\r\n        depthBuffer,\r\n        enableNormalPass,\r\n        stencilBuffer,\r\n        multisampling = 8,\r\n        frameBufferType = HalfFloatType,\r\n      },\r\n      ref\r\n    ) => {\r\n      const { gl, scene: defaultScene, camera: defaultCamera, size } = useThree()\r\n      const scene = _scene || defaultScene\r\n      const camera = _camera || defaultCamera\r\n\r\n      const [composer, normalPass, downSamplingPass] = useMemo(() => {\r\n        // Initialize composer\r\n        const effectComposer = new EffectComposerImpl(gl, {\r\n          depthBuffer,\r\n          stencilBuffer,\r\n          multisampling,\r\n          frameBufferType,\r\n        })\r\n\r\n        // Add render pass\r\n        effectComposer.addPass(new RenderPass(scene, camera))\r\n\r\n        // Create normal pass\r\n        let downSamplingPass = null\r\n        let normalPass = null\r\n        if (enableNormalPass) {\r\n          normalPass = new NormalPass(scene, camera)\r\n          normalPass.enabled = false\r\n          effectComposer.addPass(normalPass)\r\n          if (resolutionScale !== undefined) {\r\n            downSamplingPass = new DepthDownsamplingPass({ normalBuffer: normalPass.texture, resolutionScale })\r\n            downSamplingPass.enabled = false\r\n            effectComposer.addPass(downSamplingPass)\r\n          }\r\n        }\r\n\r\n        return [effectComposer, normalPass, downSamplingPass]\r\n      }, [\r\n        camera,\r\n        gl,\r\n        depthBuffer,\r\n        stencilBuffer,\r\n        multisampling,\r\n        frameBufferType,\r\n        scene,\r\n        enableNormalPass,\r\n        resolutionScale,\r\n      ])\r\n\r\n      useEffect(() => composer?.setSize(size.width, size.height), [composer, size])\r\n      useFrame(\r\n        (_, delta) => {\r\n          if (enabled) {\r\n            const currentAutoClear = gl.autoClear\r\n            gl.autoClear = autoClear\r\n            if (stencilBuffer && !autoClear) gl.clearStencil()\r\n            composer.render(delta)\r\n            gl.autoClear = currentAutoClear\r\n          }\r\n        },\r\n        enabled ? renderPriority : 0\r\n      )\r\n\r\n      const group = useRef<Group>(null!)\r\n      useLayoutEffect(() => {\r\n        const passes: Pass[] = []\r\n\r\n        // TODO: rewrite all of this with R3F v9\r\n        const groupInstance = (group.current as Group & { __r3f: Instance<Group> }).__r3f\r\n\r\n        if (groupInstance && composer) {\r\n          const children = groupInstance.children\r\n\r\n          for (let i = 0; i < children.length; i++) {\r\n            const child = children[i].object\r\n\r\n            if (child instanceof Effect) {\r\n              const effects: Effect[] = [child]\r\n\r\n              if (!isConvolution(child)) {\r\n                let next: unknown = null\r\n                while ((next = children[i + 1]?.object) instanceof Effect) {\r\n                  if (isConvolution(next)) break\r\n                  effects.push(next)\r\n                  i++\r\n                }\r\n              }\r\n\r\n              const pass = new EffectPass(camera, ...effects)\r\n              passes.push(pass)\r\n            } else if (child instanceof Pass) {\r\n              passes.push(child)\r\n            }\r\n          }\r\n\r\n          for (const pass of passes) composer?.addPass(pass)\r\n\r\n          if (normalPass) normalPass.enabled = true\r\n          if (downSamplingPass) downSamplingPass.enabled = true\r\n        }\r\n\r\n        return () => {\r\n          for (const pass of passes) composer?.removePass(pass)\r\n          if (normalPass) normalPass.enabled = false\r\n          if (downSamplingPass) downSamplingPass.enabled = false\r\n        }\r\n      }, [composer, children, camera, normalPass, downSamplingPass])\r\n\r\n      // Disable tone mapping because threejs disallows tonemapping on render targets\r\n      useEffect(() => {\r\n        const currentTonemapping = gl.toneMapping\r\n        gl.toneMapping = NoToneMapping\r\n        return () => {\r\n          gl.toneMapping = currentTonemapping\r\n        }\r\n      }, [gl])\r\n\r\n      // Memoize state, otherwise it would trigger all consumers on every render\r\n      const state = useMemo(\r\n        () => ({ composer, normalPass, downSamplingPass, resolutionScale, camera, scene }),\r\n        [composer, normalPass, downSamplingPass, resolutionScale, camera, scene]\r\n      )\r\n\r\n      // Expose the composer\r\n      useImperativeHandle(ref, () => composer, [composer])\r\n\r\n      return (\r\n        <EffectComposerContext.Provider value={state}>\r\n          <group ref={group}>{children}</group>\r\n        </EffectComposerContext.Provider>\r\n      )\r\n    }\r\n  )\r\n)\r\n","import React, { RefObject } from 'react'\r\nimport { Vector2 } from 'three'\r\nimport * as THREE from 'three'\r\nimport { type ReactThreeFiber, type ThreeElement, extend, useThree } from '@react-three/fiber'\r\nimport type { Effect, Pass, BlendFunction } from 'postprocessing'\r\n\r\nexport const resolveRef = <T,>(ref: T | React.RefObject<T>) =>\r\n  typeof ref === 'object' && ref != null && 'current' in ref ? ref.current : ref\r\n\r\nexport type EffectConstructor = new (...args: any[]) => Effect | Pass\r\n\r\nexport type EffectProps<T extends EffectConstructor> = ThreeElement<T> &\r\n  ConstructorParameters<T>[0] & {\r\n    blendFunction?: BlendFunction\r\n    opacity?: number\r\n  }\r\n\r\nlet i = 0\r\nconst components = new WeakMap<EffectConstructor, React.ExoticComponent<any> | string>()\r\n\r\nexport const wrapEffect = <T extends EffectConstructor>(effect: T, defaults?: EffectProps<T>) =>\r\n  /* @__PURE__ */ function Effect({ blendFunction = defaults?.blendFunction, opacity = defaults?.opacity, ...props }) {\r\n    let Component = components.get(effect)\r\n    if (!Component) {\r\n      const key = `@react-three/postprocessing/${effect.name}-${i++}`\r\n      extend({ [key]: effect })\r\n      components.set(effect, (Component = key))\r\n    }\r\n\r\n    const camera = useThree((state) => state.camera)\r\n    const args = React.useMemo(\r\n      () => [...(defaults?.args ?? []), ...(props.args ?? [{ ...defaults, ...props }])],\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n      [JSON.stringify(props)]\r\n    )\r\n\r\n    return (\r\n      <Component\r\n        camera={camera}\r\n        blendMode-blendFunction={blendFunction}\r\n        blendMode-opacity-value={opacity}\r\n        {...props}\r\n        args={args}\r\n      />\r\n    )\r\n  }\r\n\r\nexport const useVector2 = (props: Record<string, unknown>, key: string): THREE.Vector2 => {\r\n  const value = props[key] as ReactThreeFiber.Vector2 | undefined\r\n  return React.useMemo(() => {\r\n    if (typeof value === 'number') return new THREE.Vector2(value, value)\r\n    else if (value) return new THREE.Vector2(...(value as THREE.Vector2Tuple))\r\n    else return new THREE.Vector2()\r\n  }, [value])\r\n}\r\n","import { DepthOfFieldEffect, MaskFunction } from 'postprocessing'\r\nimport { Ref, forwardRef, useMemo, useEffect, useContext } from 'react'\r\nimport { ReactThreeFiber } from '@react-three/fiber'\r\nimport { type DepthPackingStrategies, type Texture, Vector3 } from 'three'\r\nimport { EffectComposerContext } from '../EffectComposer'\r\n\r\ntype DOFProps = ConstructorParameters<typeof DepthOfFieldEffect>[1] &\r\n  Partial<{\r\n    target: ReactThreeFiber.Vector3\r\n    depthTexture: {\r\n      texture: Texture\r\n      // TODO: narrow to DepthPackingStrategies\r\n      packing: number\r\n    }\r\n    // TODO: not used\r\n    blur: number\r\n  }>\r\n\r\nexport const DepthOfField = /* @__PURE__ */ forwardRef(function DepthOfField(\r\n  {\r\n    blendFunction,\r\n    worldFocusDistance,\r\n    worldFocusRange,\r\n    focusDistance,\r\n    focusRange,\r\n    focalLength,\r\n    bokehScale,\r\n    resolutionScale,\r\n    resolutionX,\r\n    resolutionY,\r\n    width,\r\n    height,\r\n    target,\r\n    depthTexture,\r\n    ...props\r\n  }: DOFProps,\r\n  ref: Ref<DepthOfFieldEffect>\r\n) {\r\n  const { camera } = useContext(EffectComposerContext)\r\n  const autoFocus = target != null\r\n  const effect = useMemo(() => {\r\n    const effect = new DepthOfFieldEffect(camera, {\r\n      blendFunction,\r\n      worldFocusDistance,\r\n      worldFocusRange,\r\n      focusDistance,\r\n      focusRange,\r\n      focalLength,\r\n      bokehScale,\r\n      resolutionScale,\r\n      resolutionX,\r\n      resolutionY,\r\n      width,\r\n      height,\r\n    })\r\n    // Creating a target enables autofocus, R3F will set via props\r\n    if (autoFocus) effect.target = new Vector3()\r\n    // Depth texture for depth picking with optional packing strategy\r\n    if (depthTexture) effect.setDepthTexture(depthTexture.texture, depthTexture.packing as DepthPackingStrategies)\r\n    // Temporary fix that restores DOF 6.21.3 behavior, everything since then lets shapes leak through the blur\r\n    const maskPass = (effect as any).maskPass\r\n    maskPass.maskFunction = MaskFunction.MULTIPLY_RGB_SET_ALPHA\r\n    return effect\r\n  }, [\r\n    camera,\r\n    blendFunction,\r\n    worldFocusDistance,\r\n    worldFocusRange,\r\n    focusDistance,\r\n    focusRange,\r\n    focalLength,\r\n    bokehScale,\r\n    resolutionScale,\r\n    resolutionX,\r\n    resolutionY,\r\n    width,\r\n    height,\r\n    autoFocus,\r\n    depthTexture,\r\n  ])\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      effect.dispose()\r\n    }\r\n  }, [effect])\r\n\r\n  return <primitive {...props} ref={ref} object={effect} target={target} />\r\n})\r\n","import * as THREE from 'three'\r\nimport React, {\r\n  useRef,\r\n  useContext,\r\n  useState,\r\n  useEffect,\r\n  useCallback,\r\n  forwardRef,\r\n  useImperativeHandle,\r\n  RefObject,\r\n  useMemo,\r\n} from 'react'\r\nimport { useThree, useFrame, createPortal, type Vector3 } from '@react-three/fiber'\r\nimport { CopyPass, DepthPickingPass, DepthOfFieldEffect } from 'postprocessing'\r\nimport { easing } from 'maath'\r\n\r\nimport { DepthOfField } from './DepthOfField'\r\nimport { EffectComposerContext } from '../EffectComposer'\r\n\r\nexport type AutofocusProps = React.ComponentProps<typeof DepthOfField> & {\r\n  target?: Vector3\r\n  /** should the target follow the pointer */\r\n  mouse?: boolean\r\n  /** size of the debug green point  */\r\n  debug?: number\r\n  /** manual update */\r\n  manual?: boolean\r\n  /** approximate time to reach the target */\r\n  smoothTime?: number\r\n}\r\n\r\nexport type AutofocusApi = {\r\n  dofRef: RefObject<DepthOfFieldEffect | null>\r\n  hitpoint: THREE.Vector3\r\n  update: (delta: number, updateTarget: boolean) => void\r\n}\r\n\r\nexport const Autofocus = /* @__PURE__ */ forwardRef<AutofocusApi, AutofocusProps>(\r\n  (\r\n    { target = undefined, mouse: followMouse = false, debug = undefined, manual = false, smoothTime = 0.25, ...props },\r\n    fref\r\n  ) => {\r\n    const dofRef = useRef<DepthOfFieldEffect>(null)\r\n    const hitpointRef = useRef<THREE.Mesh>(null)\r\n    const targetRef = useRef<THREE.Mesh>(null)\r\n\r\n    const scene = useThree(({ scene }) => scene)\r\n    const pointer = useThree(({ pointer }) => pointer)\r\n    const { composer, camera } = useContext(EffectComposerContext)\r\n\r\n    // see: https://codesandbox.io/s/depthpickingpass-x130hg\r\n    const [depthPickingPass] = useState(() => new DepthPickingPass())\r\n    const [copyPass] = useState(() => new CopyPass())\r\n    useEffect(() => {\r\n      composer.addPass(depthPickingPass)\r\n      composer.addPass(copyPass)\r\n      return () => {\r\n        composer.removePass(depthPickingPass)\r\n        composer.removePass(copyPass)\r\n      }\r\n    }, [composer, depthPickingPass, copyPass])\r\n\r\n    useEffect(() => {\r\n      return () => {\r\n        depthPickingPass.dispose()\r\n        copyPass.dispose()\r\n      }\r\n    }, [depthPickingPass, copyPass])\r\n\r\n    const [hitpoint] = useState(() => new THREE.Vector3(0, 0, 0))\r\n\r\n    const [ndc] = useState(() => new THREE.Vector3(0, 0, 0))\r\n    const getHit = useCallback(\r\n      async (x: number, y: number) => {\r\n        ndc.x = x\r\n        ndc.y = y\r\n        ndc.z = await depthPickingPass.readDepth(ndc)\r\n        ndc.z = ndc.z * 2.0 - 1.0\r\n        const hit = 1 - ndc.z > 0.0000001 // it is missed if ndc.z is close to 1\r\n        return hit ? ndc.unproject(camera) : false\r\n      },\r\n      [ndc, depthPickingPass, camera]\r\n    )\r\n\r\n    const update = useCallback(\r\n      async (delta: number, updateTarget = true) => {\r\n        // Update hitpoint\r\n        if (target) {\r\n          hitpoint.set(...(target as [number, number, number]))\r\n        } else {\r\n          const { x, y } = followMouse ? pointer : { x: 0, y: 0 }\r\n          const hit = await getHit(x, y)\r\n          if (hit) hitpoint.copy(hit)\r\n        }\r\n\r\n        // Update target\r\n        if (updateTarget && dofRef.current?.target) {\r\n          if (smoothTime > 0 && delta > 0) {\r\n            easing.damp3(dofRef.current.target, hitpoint, smoothTime, delta)\r\n          } else {\r\n            dofRef.current.target.copy(hitpoint)\r\n          }\r\n        }\r\n      },\r\n      [target, hitpoint, followMouse, getHit, smoothTime, pointer]\r\n    )\r\n\r\n    useFrame(async (_, delta) => {\r\n      if (!manual) {\r\n        update(delta)\r\n      }\r\n      if (hitpointRef.current) {\r\n        hitpointRef.current.position.copy(hitpoint)\r\n      }\r\n      if (targetRef.current && dofRef.current?.target) {\r\n        targetRef.current.position.copy(dofRef.current.target)\r\n      }\r\n    })\r\n\r\n    // Ref API\r\n    const api = useMemo<AutofocusApi>(\r\n      () => ({\r\n        dofRef,\r\n        hitpoint,\r\n        update,\r\n      }),\r\n      [hitpoint, update]\r\n    )\r\n    useImperativeHandle(fref, () => api, [api])\r\n\r\n    return (\r\n      <>\r\n        {debug\r\n          ? createPortal(\r\n              <>\r\n                <mesh ref={hitpointRef}>\r\n                  <sphereGeometry args={[debug, 16, 16]} />\r\n                  <meshBasicMaterial color=\"#00ff00\" opacity={1} transparent depthWrite={false} />\r\n                </mesh>\r\n                <mesh ref={targetRef}>\r\n                  <sphereGeometry args={[debug / 2, 16, 16]} />\r\n                  <meshBasicMaterial color=\"#00ff00\" opacity={0.5} transparent depthWrite={false} />\r\n                </mesh>\r\n              </>,\r\n              scene\r\n            )\r\n          : null}\r\n\r\n        <DepthOfField ref={dofRef} {...props} target={hitpoint} />\r\n      </>\r\n    )\r\n  }\r\n)\r\n","// Created by Anderson Mancini 2023\r\n// From https://github.com/ektogamat/R3F-Ultimate-Lens-Flare\r\n\r\nimport * as THREE from 'three'\r\nimport React, { useEffect, useState, useContext, useRef } from 'react'\r\nimport { useFrame, useThree } from '@react-three/fiber'\r\nimport { BlendFunction, Effect } from 'postprocessing'\r\nimport { easing } from 'maath'\r\n\r\nimport { EffectComposerContext } from '../EffectComposer'\r\nimport { wrapEffect } from '../util'\r\n\r\nconst LensFlareShader = {\r\n  fragmentShader: /* glsl */ `\r\n    uniform float time;\r\n    uniform vec2 lensPosition;\r\n    uniform vec2 screenRes;\r\n    uniform vec3 colorGain;\r\n    uniform float starPoints;\r\n    uniform float glareSize;\r\n    uniform float flareSize;\r\n    uniform float flareSpeed;\r\n    uniform float flareShape;\r\n    uniform float haloScale;\r\n    uniform float opacity;\r\n    uniform bool animated;\r\n    uniform bool anamorphic;\r\n    uniform bool enabled;\r\n    uniform bool secondaryGhosts;\r\n    uniform bool starBurst;\r\n    uniform float ghostScale;\r\n    uniform bool aditionalStreaks;\r\n    uniform sampler2D lensDirtTexture;\r\n    vec2 vTexCoord;\r\n    \r\n    float rand(float n){return fract(sin(n) * 43758.5453123);}\r\n\r\n    float noise(float p){\r\n      float fl = floor(p);\r\n      float fc = fract(p);\r\n      return mix(rand(fl),rand(fl + 1.0), fc);\r\n    }\r\n\r\n    vec3 hsv2rgb(vec3 c)\r\n    {\r\n      vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n      vec3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);\r\n      return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);\r\n    }\r\n\r\n    float saturate(float x)\r\n    {\r\n      return clamp(x, 0.,1.);\r\n    }\r\n\r\n    vec2 rotateUV(vec2 uv, float rotation)\r\n    {\r\n      return vec2(\r\n          cos(rotation) * uv.x + sin(rotation) * uv.y,\r\n          cos(rotation) * uv.y - sin(rotation) * uv.x\r\n      );\r\n    }\r\n\r\n    // Based on https://www.shadertoy.com/view/XtKfRV\r\n    vec3 drawflare(vec2 p, float intensity, float rnd, float speed, int id)\r\n    {\r\n      float flarehueoffset = (1. / 32.) * float(id) * 0.1;\r\n      float lingrad = distance(vec2(0.), p);\r\n      float expgrad = 1. / exp(lingrad * (fract(rnd) * 0.66 + 0.33));\r\n      vec3 colgrad = hsv2rgb(vec3( fract( (expgrad * 8.) + speed * flareSpeed + flarehueoffset), pow(1.-abs(expgrad*2.-1.), 0.45), 20.0 * expgrad * intensity)); //rainbow spectrum effect\r\n\r\n      float internalStarPoints;\r\n\r\n      if(anamorphic){\r\n        internalStarPoints = 1.0;\r\n      } else{\r\n        internalStarPoints = starPoints;\r\n      }\r\n      \r\n      float blades = length(p * flareShape * sin(internalStarPoints * atan(p.x, p.y)));\r\n      \r\n      float comp = pow(1.-saturate(blades), ( anamorphic ? 100. : 12.));\r\n      comp += saturate(expgrad-0.9) * 3.;\r\n      comp = pow(comp * expgrad, 8. + (1.-intensity) * 5.);\r\n      \r\n      if(flareSpeed > 0.0){\r\n        return vec3(comp) * colgrad;\r\n      } else{\r\n        return vec3(comp) * flareSize * 15.;\r\n      }\r\n    }\r\n\r\n    float dist(vec3 a, vec3 b) { return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z); }\r\n\r\n    vec3 saturate(vec3 x)\r\n    {\r\n      return clamp(x, vec3(0.0), vec3(1.0));\r\n    }\r\n\r\n    // Based on https://www.shadertoy.com/view/XtKfRV\r\n    float glare(vec2 uv, vec2 pos, float size)\r\n    {\r\n      vec2 main;\r\n\r\n      if(animated){\r\n        main = rotateUV(uv-pos, time * 0.1);      \r\n      } else{\r\n        main = uv-pos;     \r\n      }\r\n      \r\n      float ang = atan(main.y, main.x) * (anamorphic ? 1.0 : starPoints);\r\n      float dist = length(main); \r\n      dist = pow(dist, .9);\r\n      \r\n      float f0 = 1.0/(length(uv-pos)*(1.0/size*16.0)+.2);\r\n\r\n      return f0+f0*(sin((ang))*.2 +.3);\r\n    }\r\n\r\n    float sdHex(vec2 p){\r\n      p = abs(p);\r\n      vec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);\r\n      return dot(step(q.xy,q.yx), 1.0-q.yx);\r\n    }\r\n\r\n    //Based on https://www.shadertoy.com/view/dllSRX\r\n    float fpow(float x, float k){\r\n      return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\r\n    }\r\n\r\n    vec3 renderhex(vec2 uv, vec2 p, float s, vec3 col){\r\n      uv -= p;\r\n      if (abs(uv.x) < 0.2*s && abs(uv.y) < 0.2*s){\r\n          return mix(vec3(0),mix(vec3(0),col,0.1 + fpow(length(uv/s),0.1)*10.0),smoothstep(0.0,0.1,sdHex(uv*20.0/s)));\r\n      }\r\n      return vec3(0);\r\n    }\r\n\r\n    // Based on https://www.shadertoy.com/view/4sX3Rs\r\n    vec3 LensFlare(vec2 uv, vec2 pos)\r\n    {\r\n      vec2 main = uv-pos;\r\n      vec2 uvd = uv*(length(uv));\r\n      \r\n      float ang = atan(main.x,main.y);\r\n      \r\n      float f0 = .3/(length(uv-pos)*16.0+1.0);\r\n      \r\n      f0 = f0*(sin(noise(sin(ang*3.9-(animated ? time : 0.0) * 0.3) * starPoints))*.2 );\r\n      \r\n      float f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n      float f2 = max(.9/(10.0+32.0*pow(length(uvd+0.99*pos),2.0)),.0)*0.35;\r\n      float f22 = max(.9/(11.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*0.23;\r\n      float f23 = max(.9/(12.0+32.0*pow(length(uvd+0.95*pos),2.0)),.0)*0.6;\r\n      \r\n      vec2 uvx = mix(uv,uvd, 0.1);\r\n      \r\n      float f4 = max(0.01-pow(length(uvx+0.4*pos),2.9),.0)*4.02;\r\n      float f42 = max(0.0-pow(length(uvx+0.45*pos),2.9),.0)*4.1;\r\n      float f43 = max(0.01-pow(length(uvx+0.5*pos),2.9),.0)*4.6;\r\n      \r\n      uvx = mix(uv,uvd,-.4);\r\n      \r\n      float f5 = max(0.01-pow(length(uvx+0.1*pos),5.5),.0)*2.0;\r\n      float f52 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\r\n      float f53 = max(0.01-pow(length(uvx+0.1*pos),5.5),.0)*2.0;\r\n      \r\n      uvx = mix(uv,uvd, 2.1);\r\n      \r\n      float f6 = max(0.01-pow(length(uvx-0.3*pos),1.61),.0)*3.159;\r\n      float f62 = max(0.01-pow(length(uvx-0.325*pos),1.614),.0)*3.14;\r\n      float f63 = max(0.01-pow(length(uvx-0.389*pos),1.623),.0)*3.12;\r\n      \r\n      vec3 c = vec3(glare(uv,pos, glareSize));\r\n\r\n      vec2 prot;\r\n\r\n      if(animated){\r\n        prot = rotateUV(uv - pos, (time * 0.1));  \r\n      } else if(anamorphic){\r\n        prot = rotateUV(uv - pos, 1.570796);     \r\n      } else {\r\n        prot = uv - pos;\r\n      }\r\n\r\n      c += drawflare(prot, (anamorphic ? flareSize * 10. : flareSize), 0.1, time, 1);\r\n      \r\n      c.r+=f1+f2+f4+f5+f6; c.g+=f1+f22+f42+f52+f62; c.b+=f1+f23+f43+f53+f63;\r\n      c = c*1.3 * vec3(length(uvd)+.09);\r\n      c+=vec3(f0);\r\n      \r\n      return c;\r\n    }\r\n\r\n    vec3 cc(vec3 color, float factor,float factor2)\r\n    {\r\n      float w = color.x+color.y+color.z;\r\n      return mix(color,vec3(w)*factor,w*factor2);\r\n    }    \r\n\r\n    float rnd(vec2 p)\r\n    {\r\n      float f = fract(sin(dot(p, vec2(12.1234, 72.8392) )*45123.2));\r\n      return f;   \r\n    }\r\n\r\n    float rnd(float w)\r\n    {\r\n      float f = fract(sin(w)*1000.);\r\n      return f;   \r\n    }\r\n\r\n    float regShape(vec2 p, int N)\r\n    {\r\n      float f;\r\n      \r\n      float a=atan(p.x,p.y)+.2;\r\n      float b=6.28319/float(N);\r\n      f=smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy)* 2.0  -ghostScale);\r\n          \r\n      return f;\r\n    }\r\n\r\n    // Based on https://www.shadertoy.com/view/Xlc3D2\r\n    vec3 circle(vec2 p, float size, float decay, vec3 color, vec3 color2, float dist, vec2 position)\r\n    {\r\n      float l = length(p + position*(dist*2.))+size/2.;\r\n      float l2 = length(p + position*(dist*4.))+size/3.;\r\n      \r\n      float c = max(0.01-pow(length(p + position*dist), size*ghostScale), 0.0)*10.;\r\n      float c1 = max(0.001-pow(l-0.3, 1./40.)+sin(l*20.), 0.0)*3.;\r\n      float c2 =  max(0.09/pow(length(p-position*dist/.5)*1., .95), 0.0)/20.;\r\n      float s = max(0.02-pow(regShape(p*5. + position*dist*5. + decay, 6) , 1.), 0.0)*1.5;\r\n      \r\n      color = cos(vec3(0.44, .24, .2)*16. + dist/8.)*0.5+.5;\r\n      vec3 f = c*color;\r\n      f += c1*color;\r\n      f += c2*color;  \r\n      f +=  s*color;\r\n      return f;\r\n    }\r\n\r\n    vec4 getLensColor(float x){\r\n      return vec4(vec3(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(vec3(0., 0., 0.),\r\n        vec3(0., 0., 0.), smoothstep(0.0, 0.063, x)),\r\n        vec3(0., 0., 0.), smoothstep(0.063, 0.125, x)),\r\n        vec3(0.0, 0., 0.), smoothstep(0.125, 0.188, x)),\r\n        vec3(0.188, 0.131, 0.116), smoothstep(0.188, 0.227, x)),\r\n        vec3(0.31, 0.204, 0.537), smoothstep(0.227, 0.251, x)),\r\n        vec3(0.192, 0.106, 0.286), smoothstep(0.251, 0.314, x)),\r\n        vec3(0.102, 0.008, 0.341), smoothstep(0.314, 0.392, x)),\r\n        vec3(0.086, 0.0, 0.141), smoothstep(0.392, 0.502, x)),\r\n        vec3(1.0, 0.31, 0.0), smoothstep(0.502, 0.604, x)),\r\n        vec3(.1, 0.1, 0.1), smoothstep(0.604, 0.643, x)),\r\n        vec3(1.0, 0.929, 0.0), smoothstep(0.643, 0.761, x)),\r\n        vec3(1.0, 0.086, 0.424), smoothstep(0.761, 0.847, x)),\r\n        vec3(1.0, 0.49, 0.0), smoothstep(0.847, 0.89, x)),\r\n        vec3(0.945, 0.275, 0.475), smoothstep(0.89, 0.941, x)),\r\n        vec3(0.251, 0.275, 0.796), smoothstep(0.941, 1.0, x))),\r\n      1.0);\r\n    }\r\n\r\n    float dirtNoise(vec2 p){\r\n      vec2 f = fract(p);\r\n      f = (f * f) * (3.0 - (2.0 * f));    \r\n      float n = dot(floor(p), vec2(1.0, 157.0));\r\n      vec4 a = fract(sin(vec4(n + 0.0, n + 1.0, n + 157.0, n + 158.0)) * 43758.5453123);\r\n      return mix(mix(a.x, a.y, f.x), mix(a.z, a.w, f.x), f.y);\r\n    } \r\n\r\n    float fbm(vec2 p){\r\n      const mat2 m = mat2(0.80, -0.60, 0.60, 0.80);\r\n      float f = 0.0;\r\n      f += 0.5000*dirtNoise(p); p = m*p*2.02;\r\n      f += 0.2500*dirtNoise(p); p = m*p*2.03;\r\n      f += 0.1250*dirtNoise(p); p = m*p*2.01;\r\n      f += 0.0625*dirtNoise(p);\r\n      return f/0.9375;\r\n    }\r\n\r\n    vec4 getLensStar(vec2 p){\r\n      vec2 pp = (p - vec2(0.5)) * 2.0;\r\n      float a = atan(pp.y, pp.x);\r\n      vec4 cp = vec4(sin(a * 1.0), length(pp), sin(a * 13.0), sin(a * 53.0));\r\n      float d = sin(clamp(pow(length(vec2(0.5) - p) * 0.5 + haloScale /2., 5.0), 0.0, 1.0) * 3.14159);\r\n      vec3 c = vec3(d) * vec3(fbm(cp.xy * 16.0) * fbm(cp.zw * 9.0) * max(max(max(max(0.5, sin(a * 1.0)), sin(a * 3.0) * 0.8), sin(a * 7.0) * 0.8), sin(a * 9.0) * 10.6));\r\n      c *= vec3(mix(2.0, (sin(length(pp.xy) * 256.0) * 0.5) + 0.5, sin((clamp((length(pp.xy) - 0.875) / 0.1, 0.0, 1.0) + 0.0) * 2.0 * 3.14159) * 1.5) + 0.5) * 0.3275;\r\n      return vec4(vec3(c * 1.0), d);\t\r\n    }\r\n\r\n    vec4 getLensDirt(vec2 p){\r\n      p.xy += vec2(fbm(p.yx * 3.0), fbm(p.yx * 2.0)) * 0.0825;\r\n      vec3 o = vec3(mix(0.125, 0.25, max(max(smoothstep(0.1, 0.0, length(p - vec2(0.25))),\r\n                                            smoothstep(0.4, 0.0, length(p - vec2(0.75)))),\r\n                                            smoothstep(0.8, 0.0, length(p - vec2(0.875, 0.125))))));\r\n      o += vec3(max(fbm(p * 1.0) - 0.5, 0.0)) * 0.5;\r\n      o += vec3(max(fbm(p * 2.0) - 0.5, 0.0)) * 0.5;\r\n      o += vec3(max(fbm(p * 4.0) - 0.5, 0.0)) * 0.25;\r\n      o += vec3(max(fbm(p * 8.0) - 0.75, 0.0)) * 1.0;\r\n      o += vec3(max(fbm(p * 16.0) - 0.75, 0.0)) * 0.75;\r\n      o += vec3(max(fbm(p * 64.0) - 0.75, 0.0)) * 0.5;\r\n      return vec4(clamp(o, vec3(0.15), vec3(1.0)), 1.0);\t\r\n    }\r\n\r\n    vec4 textureLimited(sampler2D tex, vec2 texCoord){\r\n      if(((texCoord.x < 0.) || (texCoord.y < 0.)) || ((texCoord.x > 1.) || (texCoord.y > 1.))){\r\n        return vec4(0.0);\r\n      }else{\r\n        return texture(tex, texCoord); \r\n      }\r\n    }\r\n\r\n    vec4 textureDistorted(sampler2D tex, vec2 texCoord, vec2 direction, vec3 distortion) {\r\n      return vec4(textureLimited(tex, (texCoord + (direction * distortion.r))).r,\r\n                  textureLimited(tex, (texCoord + (direction * distortion.g))).g,\r\n                  textureLimited(tex, (texCoord + (direction * distortion.b))).b,\r\n                  1.0);\r\n    }\r\n\r\n    // Based on https://www.shadertoy.com/view/4sK3W3\r\n    vec4 getStartBurst(){\r\n      vec2 aspectTexCoord = vec2(1.0) - (((vTexCoord - vec2(0.5)) * vec2(1.0)) + vec2(0.5)); \r\n      vec2 texCoord = vec2(1.0) - vTexCoord; \r\n      vec2 ghostVec = (vec2(0.5) - texCoord) * 0.3 - lensPosition;\r\n      vec2 ghostVecAspectNormalized = normalize(ghostVec * vec2(1.0)) * vec2(1.0);\r\n      vec2 haloVec = normalize(ghostVec) * 0.6;\r\n      vec2 haloVecAspectNormalized = ghostVecAspectNormalized * 0.6;\r\n      vec2 texelSize = vec2(1.0) / vec2(screenRes.xy);\r\n      vec3 distortion = vec3(-(texelSize.x * 1.5), 0.2, texelSize.x * 1.5);\r\n      vec4 c = vec4(0.0);\r\n      for (int i = 0; i < 8; i++) {\r\n        vec2 offset = texCoord + (ghostVec * float(i));\r\n        c += textureDistorted(lensDirtTexture, offset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - offset) / length(vec2(0.5)))), 10.0);\r\n      }                       \r\n      vec2 haloOffset = texCoord + haloVecAspectNormalized; \r\n      return (c * getLensColor((length(vec2(0.5) - aspectTexCoord) / length(vec2(haloScale))))) + \r\n            (textureDistorted(lensDirtTexture, haloOffset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - haloOffset) / length(vec2(0.5)))), 10.0));\r\n    } \r\n\r\n    void mainImage(vec4 inputColor, vec2 uv, out vec4 outputColor)\r\n    {\r\n      vec2 myUV = uv -0.5;\r\n      myUV.y *= screenRes.y/screenRes.x;\r\n      vec2 finalLensPosition = lensPosition * 0.5;\r\n      finalLensPosition.y *= screenRes.y/screenRes.x;\r\n      \r\n      //First Lens flare pass\r\n      vec3 finalColor = LensFlare(myUV, finalLensPosition) * 20.0 * colorGain / 256.;\r\n\r\n      //Aditional streaks\r\n      if(aditionalStreaks){\r\n        vec3 circColor = vec3(0.9, 0.2, 0.1);\r\n        vec3 circColor2 = vec3(0.3, 0.1, 0.9);\r\n\r\n        for(float i=0.;i<10.;i++){\r\n          finalColor += circle(myUV, pow(rnd(i*2000.)*2.8, .1)+1.41, 0.0, circColor+i , circColor2+i, rnd(i*20.)*3.+0.2-.5, lensPosition);\r\n        }\r\n      }\r\n\r\n      //Alternative ghosts\r\n      if(secondaryGhosts){\r\n        vec3 altGhosts = vec3(0);\r\n        altGhosts += renderhex(myUV, -lensPosition*0.25, ghostScale * 1.4, vec3(0.25,0.35,0));\r\n        altGhosts += renderhex(myUV, lensPosition*0.25, ghostScale * 0.5, vec3(1,0.5,0.5));\r\n        altGhosts += renderhex(myUV, lensPosition*0.1, ghostScale * 1.6, vec3(1,1,1));\r\n        altGhosts += renderhex(myUV, lensPosition*1.8, ghostScale * 2.0, vec3(0,0.5,0.75));\r\n        altGhosts += renderhex(myUV, lensPosition*1.25, ghostScale * 0.8, vec3(1,1,0.5));\r\n        altGhosts += renderhex(myUV, -lensPosition*1.25, ghostScale * 5.0, vec3(0.5,0.5,0.25));\r\n        \r\n        //Circular ghosts\r\n        altGhosts += fpow(1.0 - abs(distance(lensPosition*0.8,myUV) - 0.7),0.985)*colorGain / 2100.;\r\n        finalColor += altGhosts;\r\n      }\r\n      \r\n\r\n      //Starburst                     \r\n      if(starBurst){\r\n        vTexCoord = myUV + 0.5;\r\n        vec4 lensMod = getLensDirt(myUV);\r\n        float tooBright = 1.0 - (clamp(0.5, 0.0, 0.5) * 2.0); \r\n        float tooDark = clamp(0.5 - 0.5, 0.0, 0.5) * 2.0;\r\n        lensMod += mix(lensMod, pow(lensMod * 2.0, vec4(2.0)) * 0.5, tooBright);\r\n        float lensStarRotationAngle = ((myUV.x + myUV.y)) * (1.0 / 6.0);\r\n        vec2 lensStarTexCoord = (mat2(cos(lensStarRotationAngle), -sin(lensStarRotationAngle), sin(lensStarRotationAngle), cos(lensStarRotationAngle)) * vTexCoord);\r\n        lensMod += getLensStar(lensStarTexCoord) * 2.;\r\n        \r\n        finalColor += clamp((lensMod.rgb * getStartBurst().rgb ), 0.01, 1.0);\r\n      }\r\n\r\n      //Final composed output\r\n      if(enabled){\r\n        outputColor = vec4(mix(finalColor, vec3(.0), opacity) + inputColor.rgb, inputColor.a);\r\n      } else {\r\n        outputColor = vec4(inputColor);\r\n      }\r\n    }\r\n  `,\r\n}\r\n\r\ntype LensFlareEffectOptions = {\r\n  /** The blend function of this effect */\r\n  blendFunction: BlendFunction\r\n  /** Boolean to enable/disable the effect */\r\n  enabled: boolean\r\n  /** The glare size */\r\n  glareSize: number\r\n  /** The position of the lens flare in 3d space */\r\n  lensPosition: THREE.Vector3\r\n  /** Effect resolution */\r\n  screenRes: THREE.Vector2\r\n  /** The number of points for the star */\r\n  starPoints: number\r\n  /** The flare side */\r\n  flareSize: number\r\n  /** The flare animation speed */\r\n  flareSpeed: number\r\n  /** Changes the appearance to anamorphic */\r\n  flareShape: number\r\n  /** Animated flare */\r\n  animated: boolean\r\n  /** Set the appearance to full anamorphic */\r\n  anamorphic: boolean\r\n  /** Set the color gain for the lens flare. Must be a THREE.Color in RBG format */\r\n  colorGain: THREE.Color\r\n  /** Texture to be used as color dirt for starburst effect */\r\n  lensDirtTexture: THREE.Texture | null\r\n  /** The halo scale */\r\n  haloScale: number\r\n  /** Option to enable/disable secondary ghosts */\r\n  secondaryGhosts: boolean\r\n  /** Option to enable/disable aditional streaks */\r\n  aditionalStreaks: boolean\r\n  /** Option to enable/disable secondary ghosts */\r\n  ghostScale: number\r\n  /** TODO The opacity for this effect */\r\n  opacity: number\r\n  /** Boolean to enable/disable the start burst effect. Can be disabled to improve performance */\r\n  starBurst: boolean\r\n}\r\n\r\nexport class LensFlareEffect extends Effect {\r\n  constructor({\r\n    blendFunction,\r\n    enabled,\r\n    glareSize,\r\n    lensPosition,\r\n    screenRes,\r\n    starPoints,\r\n    flareSize,\r\n    flareSpeed,\r\n    flareShape,\r\n    animated,\r\n    anamorphic,\r\n    colorGain,\r\n    lensDirtTexture,\r\n    haloScale,\r\n    secondaryGhosts,\r\n    aditionalStreaks,\r\n    ghostScale,\r\n    opacity,\r\n    starBurst,\r\n  }: LensFlareEffectOptions) {\r\n    super('LensFlareEffect', LensFlareShader.fragmentShader, {\r\n      blendFunction,\r\n      uniforms: new Map<string, THREE.Uniform>([\r\n        ['enabled', new THREE.Uniform(enabled)],\r\n        ['glareSize', new THREE.Uniform(glareSize)],\r\n        ['lensPosition', new THREE.Uniform(lensPosition)],\r\n        ['time', new THREE.Uniform(0)],\r\n        ['screenRes', new THREE.Uniform(screenRes)],\r\n        ['starPoints', new THREE.Uniform(starPoints)],\r\n        ['flareSize', new THREE.Uniform(flareSize)],\r\n        ['flareSpeed', new THREE.Uniform(flareSpeed)],\r\n        ['flareShape', new THREE.Uniform(flareShape)],\r\n        ['animated', new THREE.Uniform(animated)],\r\n        ['anamorphic', new THREE.Uniform(anamorphic)],\r\n        ['colorGain', new THREE.Uniform(colorGain)],\r\n        ['lensDirtTexture', new THREE.Uniform(lensDirtTexture)],\r\n        ['haloScale', new THREE.Uniform(haloScale)],\r\n        ['secondaryGhosts', new THREE.Uniform(secondaryGhosts)],\r\n        ['aditionalStreaks', new THREE.Uniform(aditionalStreaks)],\r\n        ['ghostScale', new THREE.Uniform(ghostScale)],\r\n        ['starBurst', new THREE.Uniform(starBurst)],\r\n        ['opacity', new THREE.Uniform(opacity)],\r\n      ]),\r\n    })\r\n  }\r\n\r\n  update(_renderer: any, _inputBuffer: any, deltaTime: number) {\r\n    const time = this.uniforms.get('time')\r\n    if (time) {\r\n      time.value += deltaTime\r\n    }\r\n  }\r\n}\r\n\r\ntype LensFlareProps = {\r\n  /** Position of the effect */\r\n  lensPosition?: THREE.Vector3\r\n  /** The time that it takes to fade the occlusion */\r\n  smoothTime?: number\r\n} & Partial<LensFlareEffectOptions>\r\n\r\nconst LensFlareWrapped = /* @__PURE__ */ wrapEffect(LensFlareEffect)\r\n\r\nexport const LensFlare = ({\r\n  smoothTime = 0.07,\r\n  //\r\n  blendFunction = BlendFunction.NORMAL,\r\n  enabled = true,\r\n  glareSize = 0.2,\r\n  lensPosition = new THREE.Vector3(-25, 6, -60),\r\n  screenRes = new THREE.Vector2(0, 0),\r\n  starPoints = 6,\r\n  flareSize = 0.01,\r\n  flareSpeed = 0.01,\r\n  flareShape = 0.01,\r\n  animated = true,\r\n  anamorphic = false,\r\n  colorGain = new THREE.Color(20, 20, 20),\r\n  lensDirtTexture = null,\r\n  haloScale = 0.5,\r\n  secondaryGhosts = true,\r\n  aditionalStreaks = true,\r\n  ghostScale = 0.0,\r\n  opacity = 1.0,\r\n  starBurst = false,\r\n}: LensFlareProps) => {\r\n  const viewport = useThree(({ viewport }) => viewport)\r\n  const raycaster = useThree(({ raycaster }) => raycaster)\r\n  const { scene, camera } = useContext(EffectComposerContext)\r\n  const [raycasterPos] = useState(() => new THREE.Vector2())\r\n  const [projectedPosition] = useState(() => new THREE.Vector3())\r\n\r\n  const ref = useRef<LensFlareEffect>(null)\r\n\r\n  useFrame((_, delta) => {\r\n    if (!ref?.current) return\r\n    const uLensPosition = ref.current.uniforms.get('lensPosition')\r\n    const uOpacity = ref.current.uniforms.get('opacity')\r\n    if (!uLensPosition || !uOpacity) return\r\n\r\n    let target = 1\r\n\r\n    projectedPosition.copy(lensPosition).project(camera)\r\n    if (projectedPosition.z > 1) return\r\n\r\n    uLensPosition.value.x = projectedPosition.x\r\n    uLensPosition.value.y = projectedPosition.y\r\n    raycasterPos.x = projectedPosition.x\r\n    raycasterPos.y = projectedPosition.y\r\n    raycaster.setFromCamera(raycasterPos, camera)\r\n\r\n    const intersects = raycaster.intersectObjects(scene.children, true)\r\n    const { object } = intersects[0] || {}\r\n    if (object) {\r\n      if (object.userData?.lensflare === 'no-occlusion') {\r\n        target = 0\r\n      } else if (object instanceof THREE.Mesh) {\r\n        if (object.material.uniforms?._transmission?.value > 0.2) {\r\n          //Check for MeshTransmissionMaterial\r\n          target = 0.2\r\n        } else if (object.material._transmission && object.material._transmission > 0.2) {\r\n          //Check for MeshPhysicalMaterial with transmission setting\r\n          target = 0.2\r\n        } else if (object.material.transparent) {\r\n          // Check for OtherMaterials with transparent parameter\r\n          target = object.material.opacity\r\n        }\r\n      }\r\n    }\r\n\r\n    easing.damp(uOpacity, 'value', target, smoothTime, delta)\r\n  })\r\n\r\n  useEffect(() => {\r\n    if (!ref?.current) return\r\n\r\n    const screenRes = ref.current.uniforms.get('screenRes')\r\n    if (screenRes) {\r\n      screenRes.value.x = viewport.width\r\n      screenRes.value.y = viewport.height\r\n    }\r\n  }, [viewport])\r\n\r\n  return (\r\n    <LensFlareWrapped\r\n      ref={ref}\r\n      blendFunction={blendFunction}\r\n      enabled={enabled}\r\n      glareSize={glareSize}\r\n      lensPosition={lensPosition}\r\n      screenRes={screenRes}\r\n      starPoints={starPoints}\r\n      flareSize={flareSize}\r\n      flareSpeed={flareSpeed}\r\n      flareShape={flareShape}\r\n      animated={animated}\r\n      anamorphic={anamorphic}\r\n      colorGain={colorGain}\r\n      lensDirtTexture={lensDirtTexture}\r\n      haloScale={haloScale}\r\n      secondaryGhosts={secondaryGhosts}\r\n      aditionalStreaks={aditionalStreaks}\r\n      ghostScale={ghostScale}\r\n      opacity={opacity}\r\n      starBurst={starBurst}\r\n    />\r\n  )\r\n}\r\n","import { BloomEffect, BlendFunction } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const Bloom = /* @__PURE__ */ wrapEffect(BloomEffect, {\r\n  blendFunction: BlendFunction.ADD,\r\n})\r\n","import { BrightnessContrastEffect } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const BrightnessContrast = /* @__PURE__ */ wrapEffect(BrightnessContrastEffect)\r\n","import { ChromaticAberrationEffect } from 'postprocessing'\r\nimport { type EffectProps, wrapEffect } from '../util'\r\n\r\nexport type ChromaticAberrationProps = EffectProps<typeof ChromaticAberrationEffect>\r\nexport const ChromaticAberration = /* @__PURE__ */ wrapEffect(ChromaticAberrationEffect)\r\n","import { ColorAverageEffect, BlendFunction } from 'postprocessing'\r\nimport React, { Ref, forwardRef, useMemo } from 'react'\r\n\r\nexport type ColorAverageProps = Partial<{\r\n  blendFunction: BlendFunction\r\n}>\r\n\r\nexport const ColorAverage = /* @__PURE__ */ forwardRef<ColorAverageEffect, ColorAverageProps>(function ColorAverage(\r\n  { blendFunction = BlendFunction.NORMAL }: ColorAverageProps,\r\n  ref: Ref<ColorAverageEffect>\r\n) {\r\n  /** Because ColorAverage blendFunction is not an object but a number, we have to define a custom prop \"blendFunction\" */\r\n  const effect = useMemo(() => new ColorAverageEffect(blendFunction), [blendFunction])\r\n  return <primitive ref={ref} object={effect} dispose={null} />\r\n})\r\n","import { ColorDepthEffect } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const ColorDepth = /* @__PURE__ */ wrapEffect(ColorDepthEffect)\r\n","import { DepthEffect } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const Depth = /* @__PURE__ */ wrapEffect(DepthEffect)\r\n","import { DotScreenEffect } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const DotScreen = /* @__PURE__ */ wrapEffect(DotScreenEffect)\r\n","import { Vector2 } from 'three'\r\nimport { GlitchEffect, GlitchMode } from 'postprocessing'\r\nimport { Ref, forwardRef, useMemo, useLayoutEffect, useEffect } from 'react'\r\nimport { ReactThreeFiber, useThree } from '@react-three/fiber'\r\nimport { useVector2 } from '../util'\r\n\r\nexport type GlitchProps = ConstructorParameters<typeof GlitchEffect>[0] &\r\n  Partial<{\r\n    mode: GlitchMode\r\n    active: boolean\r\n    delay: ReactThreeFiber.Vector2\r\n    duration: ReactThreeFiber.Vector2\r\n    chromaticAberrationOffset: ReactThreeFiber.Vector2\r\n    strength: ReactThreeFiber.Vector2\r\n  }>\r\n\r\nexport const Glitch = /* @__PURE__ */ forwardRef<GlitchEffect, GlitchProps>(function Glitch(\r\n  { active = true, ...props }: GlitchProps,\r\n  ref: Ref<GlitchEffect>\r\n) {\r\n  const invalidate = useThree((state) => state.invalidate)\r\n  const delay = useVector2(props, 'delay')\r\n  const duration = useVector2(props, 'duration')\r\n  const strength = useVector2(props, 'strength')\r\n  const chromaticAberrationOffset = useVector2(props, 'chromaticAberrationOffset')\r\n  const effect = useMemo(\r\n    () => new GlitchEffect({ ...props, delay, duration, strength, chromaticAberrationOffset }),\r\n    [delay, duration, props, strength, chromaticAberrationOffset]\r\n  )\r\n  useLayoutEffect(() => {\r\n    effect.mode = active ? props.mode || GlitchMode.SPORADIC : GlitchMode.DISABLED\r\n    invalidate()\r\n  }, [active, effect, invalidate, props.mode])\r\n  useEffect(() => {\r\n    return () => {\r\n      effect.dispose?.()\r\n    }\r\n  }, [effect])\r\n  return <primitive ref={ref} object={effect} dispose={null} />\r\n})\r\n","import { GodRaysEffect } from 'postprocessing'\r\nimport React, { Ref, forwardRef, useMemo, useContext, useLayoutEffect } from 'react'\r\nimport { Mesh, Points } from 'three'\r\nimport { EffectComposerContext } from '../EffectComposer'\r\nimport { resolveRef } from '../util'\r\n\r\ntype GodRaysProps = ConstructorParameters<typeof GodRaysEffect>[2] & {\r\n  sun: Mesh | Points | React.RefObject<Mesh | Points>\r\n}\r\n\r\nexport const GodRays = /* @__PURE__ */ forwardRef(function GodRays(props: GodRaysProps, ref: Ref<GodRaysEffect>) {\r\n  const { camera } = useContext(EffectComposerContext)\r\n  const effect = useMemo(() => new GodRaysEffect(camera, resolveRef(props.sun), props), [camera, props])\r\n  useLayoutEffect(() => void (effect.lightSource = resolveRef(props.sun)), [effect, props.sun])\r\n  return <primitive ref={ref} object={effect} dispose={null} />\r\n})\r\n","import React, { Ref, forwardRef, useMemo, useLayoutEffect } from 'react'\r\nimport { GridEffect } from 'postprocessing'\r\nimport { useThree } from '@react-three/fiber'\r\n\r\ntype GridProps = ConstructorParameters<typeof GridEffect>[0] &\r\n  Partial<{\r\n    size: {\r\n      width: number\r\n      height: number\r\n    }\r\n  }>\r\n\r\nexport const Grid = /* @__PURE__ */ forwardRef(function Grid({ size, ...props }: GridProps, ref: Ref<GridEffect>) {\r\n  const invalidate = useThree((state) => state.invalidate)\r\n  const effect = useMemo(() => new GridEffect(props), [props])\r\n  useLayoutEffect(() => {\r\n    if (size) effect.setSize(size.width, size.height)\r\n    invalidate()\r\n  }, [effect, size, invalidate])\r\n  return <primitive ref={ref} object={effect} dispose={null} />\r\n})\r\n","import { HueSaturationEffect } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const HueSaturation = /* @__PURE__ */ wrapEffect(HueSaturationEffect)\r\n","import { NoiseEffect, BlendFunction } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const Noise = /* @__PURE__ */ wrapEffect(NoiseEffect, { blendFunction: BlendFunction.COLOR_DODGE })\r\n","import { OutlineEffect } from 'postprocessing'\r\nimport { Ref, RefObject, forwardRef, useMemo, useEffect, useContext, useRef } from 'react'\r\nimport { Object3D } from 'three'\r\nimport { useThree } from '@react-three/fiber'\r\nimport { EffectComposerContext } from '../EffectComposer'\r\nimport { selectionContext } from '../Selection'\r\nimport { resolveRef } from '../util'\r\n\r\ntype ObjectRef = RefObject<Object3D>\r\n\r\nexport type OutlineProps = ConstructorParameters<typeof OutlineEffect>[2] &\r\n  Partial<{\r\n    selection: Object3D | Object3D[] | ObjectRef | ObjectRef[]\r\n    selectionLayer: number\r\n  }>\r\n\r\nexport const Outline = /* @__PURE__ */ forwardRef(function Outline(\r\n  {\r\n    selection = [],\r\n    selectionLayer = 10,\r\n    blendFunction,\r\n    patternTexture,\r\n    edgeStrength,\r\n    pulseSpeed,\r\n    visibleEdgeColor,\r\n    hiddenEdgeColor,\r\n    width,\r\n    height,\r\n    kernelSize,\r\n    blur,\r\n    xRay,\r\n    ...props\r\n  }: OutlineProps,\r\n  forwardRef: Ref<OutlineEffect>\r\n) {\r\n  const invalidate = useThree((state) => state.invalidate)\r\n  const { scene, camera } = useContext(EffectComposerContext)\r\n\r\n  const effect = useMemo(\r\n    () =>\r\n      new OutlineEffect(scene, camera, {\r\n        blendFunction,\r\n        patternTexture,\r\n        edgeStrength,\r\n        pulseSpeed,\r\n        visibleEdgeColor,\r\n        hiddenEdgeColor,\r\n        width,\r\n        height,\r\n        kernelSize,\r\n        blur,\r\n        xRay,\r\n        ...props,\r\n      }),\r\n    // NOTE: `props` is an unstable reference, so we can't memoize it\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    [\r\n      blendFunction,\r\n      blur,\r\n      camera,\r\n      edgeStrength,\r\n      height,\r\n      hiddenEdgeColor,\r\n      kernelSize,\r\n      patternTexture,\r\n      pulseSpeed,\r\n      scene,\r\n      visibleEdgeColor,\r\n      width,\r\n      xRay,\r\n    ]\r\n  )\r\n\r\n  const api = useContext(selectionContext)\r\n\r\n  useEffect(() => {\r\n    // Do not allow array selection if declarative selection is active\r\n    // TODO: array selection should probably be deprecated altogether\r\n    if (!api && selection) {\r\n      effect.selection.set(\r\n        Array.isArray(selection) ? (selection as Object3D[]).map(resolveRef) : [resolveRef(selection) as Object3D]\r\n      )\r\n      invalidate()\r\n      return () => {\r\n        effect.selection.clear()\r\n        invalidate()\r\n      }\r\n    }\r\n  }, [effect, selection, api, invalidate])\r\n\r\n  useEffect(() => {\r\n    effect.selectionLayer = selectionLayer\r\n    invalidate()\r\n  }, [effect, invalidate, selectionLayer])\r\n\r\n  const ref = useRef<OutlineEffect>(undefined)\r\n  useEffect(() => {\r\n    if (api && api.enabled) {\r\n      if (api.selected?.length) {\r\n        effect.selection.set(api.selected)\r\n        invalidate()\r\n        return () => {\r\n          effect.selection.clear()\r\n          invalidate()\r\n        }\r\n      }\r\n    }\r\n  }, [api, effect.selection, invalidate])\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      effect.dispose()\r\n    }\r\n  }, [effect])\r\n\r\n  return <primitive ref={forwardRef} object={effect} />\r\n})\r\n","import { forwardRef, useMemo, Ref } from 'react'\r\nimport { PixelationEffect } from 'postprocessing'\r\n\r\nexport type PixelationProps = {\r\n  granularity?: number\r\n}\r\n\r\nexport const Pixelation = /* @__PURE__ */ forwardRef<PixelationEffect, PixelationProps>(function Pixelation(\r\n  { granularity = 5 }: PixelationProps,\r\n  ref: Ref<PixelationEffect>\r\n) {\r\n  /** Because GlitchEffect granularity is not an object but a number, we have to define a custom prop \"granularity\" */\r\n  const effect = useMemo(() => new PixelationEffect(granularity), [granularity])\r\n  return <primitive ref={ref} object={effect} dispose={null} />\r\n})\r\n","import { ScanlineEffect, BlendFunction } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const Scanline = /* @__PURE__ */ wrapEffect(ScanlineEffect, {\r\n  blendFunction: BlendFunction.OVERLAY,\r\n  density: 1.25,\r\n})\r\n","import { SelectiveBloomEffect, BlendFunction } from 'postprocessing'\r\nimport type { BloomEffectOptions } from 'postprocessing'\r\nimport React, { Ref, RefObject, forwardRef, useMemo, useEffect, useContext, useRef } from 'react'\r\nimport { Object3D } from 'three'\r\nimport { useThree } from '@react-three/fiber'\r\nimport { EffectComposerContext } from '../EffectComposer'\r\nimport { selectionContext } from '../Selection'\r\nimport { resolveRef } from '../util'\r\n\r\ntype ObjectRef = RefObject<Object3D>\r\n\r\nexport type SelectiveBloomProps = BloomEffectOptions &\r\n  Partial<{\r\n    lights: Object3D[] | ObjectRef[]\r\n    selection: Object3D | Object3D[] | ObjectRef | ObjectRef[]\r\n    selectionLayer: number\r\n    inverted: boolean\r\n    ignoreBackground: boolean\r\n  }>\r\n\r\nconst addLight = (light: Object3D, effect: SelectiveBloomEffect) => light.layers.enable(effect.selection.layer)\r\nconst removeLight = (light: Object3D, effect: SelectiveBloomEffect) => light.layers.disable(effect.selection.layer)\r\n\r\nexport const SelectiveBloom = /* @__PURE__ */ forwardRef(function SelectiveBloom(\r\n  {\r\n    selection = [],\r\n    selectionLayer = 10,\r\n    lights = [],\r\n    inverted = false,\r\n    ignoreBackground = false,\r\n    luminanceThreshold,\r\n    luminanceSmoothing,\r\n    intensity,\r\n    width,\r\n    height,\r\n    kernelSize,\r\n    mipmapBlur,\r\n\r\n    ...props\r\n  }: SelectiveBloomProps,\r\n  forwardRef: Ref<SelectiveBloomEffect>\r\n) {\r\n  if (lights.length === 0) {\r\n    console.warn('SelectiveBloom requires lights to work.')\r\n  }\r\n\r\n  const invalidate = useThree((state) => state.invalidate)\r\n  const { scene, camera } = useContext(EffectComposerContext)\r\n  const effect = useMemo(() => {\r\n    const effect = new SelectiveBloomEffect(scene, camera, {\r\n      blendFunction: BlendFunction.ADD,\r\n      luminanceThreshold,\r\n      luminanceSmoothing,\r\n      intensity,\r\n      width,\r\n      height,\r\n      kernelSize,\r\n      mipmapBlur,\r\n      ...props,\r\n    })\r\n    effect.inverted = inverted\r\n    effect.ignoreBackground = ignoreBackground\r\n    return effect\r\n  }, [\r\n    scene,\r\n    camera,\r\n    luminanceThreshold,\r\n    luminanceSmoothing,\r\n    intensity,\r\n    width,\r\n    height,\r\n    kernelSize,\r\n    mipmapBlur,\r\n    inverted,\r\n    ignoreBackground,\r\n    props,\r\n  ])\r\n\r\n  const api = useContext(selectionContext)\r\n\r\n  useEffect(() => {\r\n    // Do not allow array selection if declarative selection is active\r\n    // TODO: array selection should probably be deprecated altogether\r\n    if (!api && selection) {\r\n      effect.selection.set(\r\n        Array.isArray(selection) ? (selection as Object3D[]).map(resolveRef) : [resolveRef(selection) as Object3D]\r\n      )\r\n      invalidate()\r\n      return () => {\r\n        effect.selection.clear()\r\n        invalidate()\r\n      }\r\n    }\r\n  }, [effect, selection, api, invalidate])\r\n\r\n  useEffect(() => {\r\n    effect.selection.layer = selectionLayer\r\n    invalidate()\r\n  }, [effect, invalidate, selectionLayer])\r\n\r\n  useEffect(() => {\r\n    if (lights && lights.length > 0) {\r\n      lights.forEach((light) => addLight(resolveRef(light), effect))\r\n      invalidate()\r\n      return () => {\r\n        lights.forEach((light) => removeLight(resolveRef(light), effect))\r\n        invalidate()\r\n      }\r\n    }\r\n  }, [effect, invalidate, lights, selectionLayer])\r\n\r\n  useEffect(() => {\r\n    if (api && api.enabled) {\r\n      if (api.selected?.length) {\r\n        effect.selection.set(api.selected)\r\n        invalidate()\r\n        return () => {\r\n          effect.selection.clear()\r\n          invalidate()\r\n        }\r\n      }\r\n    }\r\n  }, [api, effect.selection, invalidate])\r\n\r\n  return <primitive ref={forwardRef} object={effect} dispose={null} />\r\n})\r\n","import { SepiaEffect } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const Sepia = /* @__PURE__ */ wrapEffect(SepiaEffect)\r\n","import { Ref, forwardRef, useContext, useMemo } from 'react'\r\nimport { SSAOEffect, BlendFunction } from 'postprocessing'\r\nimport { EffectComposerContext } from '../EffectComposer'\r\n\r\n// first two args are camera and texture\r\ntype SSAOProps = ConstructorParameters<typeof SSAOEffect>[2]\r\n\r\nexport const SSAO = /* @__PURE__ */ forwardRef<SSAOEffect, SSAOProps>(function SSAO(\r\n  props: SSAOProps,\r\n  ref: Ref<SSAOEffect>\r\n) {\r\n  const { camera, normalPass, downSamplingPass, resolutionScale } = useContext(EffectComposerContext)\r\n  const effect = useMemo<SSAOEffect | {}>(() => {\r\n    if (normalPass === null && downSamplingPass === null) {\r\n      console.error('Please enable the NormalPass in the EffectComposer in order to use SSAO.')\r\n      return {}\r\n    }\r\n    return new SSAOEffect(camera, normalPass && !downSamplingPass ? (normalPass as any).texture : null, {\r\n      blendFunction: BlendFunction.MULTIPLY,\r\n      samples: 30,\r\n      rings: 4,\r\n      distanceThreshold: 1.0,\r\n      distanceFalloff: 0.0,\r\n      rangeThreshold: 0.5,\r\n      rangeFalloff: 0.1,\r\n      luminanceInfluence: 0.9,\r\n      radius: 20,\r\n      bias: 0.5,\r\n      intensity: 1.0,\r\n      color: undefined,\r\n      // @ts-ignore\r\n      normalDepthBuffer: downSamplingPass ? downSamplingPass.texture : null,\r\n      resolutionScale: resolutionScale ?? 1,\r\n      depthAwareUpsampling: true,\r\n      ...props,\r\n    })\r\n    // NOTE: `props` is an unstable reference, so we can't memoize it\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [camera, downSamplingPass, normalPass, resolutionScale])\r\n  return <primitive ref={ref} object={effect} dispose={null} />\r\n})\r\n","import { SMAAEffect } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const SMAA = /* @__PURE__ */ wrapEffect(SMAAEffect)\r\n","import { FXAAEffect } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const FXAA = /* @__PURE__ */ wrapEffect(FXAAEffect)\r\n","import { Uniform } from 'three'\r\nimport { Effect } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nconst RampShader = {\r\n  fragmentShader: /* glsl */ `\r\n    uniform int rampType;\r\n\r\n    uniform vec2 rampStart;\r\n    uniform vec2 rampEnd;\r\n\r\n    uniform vec4 startColor;\r\n    uniform vec4 endColor;\r\n\r\n    uniform float rampBias;\r\n    uniform float rampGain;\r\n\r\n    uniform bool rampMask;\r\n    uniform bool rampInvert;\r\n\r\n    float getBias(float time, float bias) {\r\n      return time / (((1.0 / bias) - 2.0) * (1.0 - time) + 1.0);\r\n    }\r\n\r\n    float getGain(float time, float gain) {\r\n      if (time < 0.5)\r\n        return getBias(time * 2.0, gain) / 2.0;\r\n      else\r\n        return getBias(time * 2.0 - 1.0, 1.0 - gain) / 2.0 + 0.5;\r\n    }\r\n\r\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n      vec2 centerPixel = uv * resolution;\r\n      vec2 startPixel = rampStart * resolution;\r\n      vec2 endPixel = rampEnd * resolution;\r\n\r\n      float rampAlpha;\r\n\r\n      if (rampType == 1) {\r\n        vec2 fuv = centerPixel / resolution.y;\r\n        vec2 suv = startPixel / resolution.y;\r\n        vec2 euv = endPixel / resolution.y;\r\n\r\n        float radius = length(suv - euv);\r\n        float falloff = length(fuv - suv);\r\n        rampAlpha = smoothstep(0.0, radius, falloff);\r\n      } else {\r\n        float radius = length(startPixel - endPixel);\r\n        vec2 direction = normalize(vec2(endPixel.x - startPixel.x, -(startPixel.y - endPixel.y)));\r\n\r\n        float fade = dot(centerPixel - startPixel, direction);\r\n        if (rampType == 2) fade = abs(fade);\r\n\r\n        rampAlpha = smoothstep(0.0, 1.0, fade / radius);\r\n      }\r\n\r\n      rampAlpha = abs((rampInvert ? 1.0 : 0.0) - getBias(rampAlpha, rampBias) * getGain(rampAlpha, rampGain));\r\n\r\n      if (rampMask) {\r\n        vec4 inputBuff = texture2D(inputBuffer, uv);\r\n        outputColor = mix(inputBuff, inputColor, rampAlpha);\r\n      } else {\r\n        outputColor = mix(startColor, endColor, rampAlpha);\r\n      }\r\n    }\r\n  `,\r\n}\r\n\r\nexport enum RampType {\r\n  Linear,\r\n  Radial,\r\n  MirroredLinear,\r\n}\r\n\r\nexport class RampEffect extends Effect {\r\n  constructor({\r\n    /**\r\n     * Type of ramp gradient.\r\n     */\r\n    rampType = RampType.Linear,\r\n    /**\r\n     * Starting point of the ramp gradient in normalized coordinates.\r\n     *\r\n     * Ranges from `[0 - 1]` as `[x, y]`. Default is `[0.5, 0.5]`.\r\n     */\r\n    rampStart = [0.5, 0.5],\r\n    /**\r\n     * Ending point of the ramp gradient in normalized coordinates.\r\n     *\r\n     * Ranges from `[0 - 1]` as `[x, y]`. Default is `[1, 1]`\r\n     */\r\n    rampEnd = [1, 1],\r\n    /**\r\n     * Color at the starting point of the gradient.\r\n     *\r\n     * Default is black: `[0, 0, 0, 1]`\r\n     */\r\n    startColor = [0, 0, 0, 1],\r\n    /**\r\n     * Color at the ending point of the gradient.\r\n     *\r\n     * Default is white: `[1, 1, 1, 1]`\r\n     */\r\n    endColor = [1, 1, 1, 1],\r\n    /**\r\n     * Bias for the interpolation curve when both bias and gain are 0.5.\r\n     *\r\n     * Ranges from `[0 - 1]`. Default is `0.5`.\r\n     */\r\n    rampBias = 0.5,\r\n    /**\r\n     * Gain for the interpolation curve when both bias and gain are 0.5.\r\n     *\r\n     * Ranges from `[0 - 1]`. Default is `0.5`.\r\n     */\r\n    rampGain = 0.5,\r\n    /**\r\n     * When enabled, the ramp gradient is used as an effect mask, and colors are ignored.\r\n     *\r\n     * Default is `false`.\r\n     */\r\n    rampMask = false,\r\n    /**\r\n     * Controls whether the ramp gradient is inverted.\r\n     *\r\n     * When disabled, rampStart is transparent and rampEnd is opaque.\r\n     *\r\n     * Default is `false`.\r\n     */\r\n    rampInvert = false,\r\n    ...params\r\n  } = {}) {\r\n    super('RampEffect', RampShader.fragmentShader, {\r\n      ...params,\r\n      uniforms: new Map<string, Uniform>([\r\n        ['rampType', new Uniform(rampType)],\r\n        ['rampStart', new Uniform(rampStart)],\r\n        ['rampEnd', new Uniform(rampEnd)],\r\n        ['startColor', new Uniform(startColor)],\r\n        ['endColor', new Uniform(endColor)],\r\n        ['rampBias', new Uniform(rampBias)],\r\n        ['rampGain', new Uniform(rampGain)],\r\n        ['rampMask', new Uniform(rampMask)],\r\n        ['rampInvert', new Uniform(rampInvert)],\r\n      ]),\r\n    })\r\n  }\r\n}\r\n\r\nexport const Ramp = /* @__PURE__ */ wrapEffect(RampEffect)\r\n","import { TextureEffect } from 'postprocessing'\r\nimport { Ref, forwardRef, useMemo, useLayoutEffect } from 'react'\r\nimport { useLoader } from '@react-three/fiber'\r\nimport { TextureLoader, SRGBColorSpace, RepeatWrapping } from 'three'\r\n\r\ntype TextureProps = ConstructorParameters<typeof TextureEffect>[0] & {\r\n  textureSrc: string\r\n  /** opacity of provided texture */\r\n  opacity?: number\r\n}\r\n\r\nexport const Texture = /* @__PURE__ */ forwardRef<TextureEffect, TextureProps>(function Texture(\r\n  { textureSrc, texture, opacity = 1, ...props }: TextureProps,\r\n  ref: Ref<TextureEffect>\r\n) {\r\n  const t = useLoader(TextureLoader, textureSrc)\r\n  useLayoutEffect(() => {\r\n    t.colorSpace = SRGBColorSpace\r\n    t.wrapS = t.wrapT = RepeatWrapping\r\n  }, [t])\r\n  const effect = useMemo(() => new TextureEffect({ ...props, texture: t || texture }), [props, t, texture])\r\n  return <primitive ref={ref} object={effect} blendMode-opacity-value={opacity} dispose={null} />\r\n})\r\n","import { ToneMappingEffect } from 'postprocessing'\r\nimport { type EffectProps, wrapEffect } from '../util'\r\n\r\nexport type ToneMappingProps = EffectProps<typeof ToneMappingEffect>\r\n\r\nexport const ToneMapping = /* @__PURE__ */ wrapEffect(ToneMappingEffect)\r\n","import { VignetteEffect } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const Vignette = /* @__PURE__ */ wrapEffect(VignetteEffect)\r\n","import { ShockWaveEffect } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const ShockWave = /* @__PURE__ */ wrapEffect(ShockWaveEffect)\r\n","import { useThree } from '@react-three/fiber'\r\nimport { LUT3DEffect, BlendFunction } from 'postprocessing'\r\nimport React, { forwardRef, Ref, useLayoutEffect, useMemo } from 'react'\r\nimport type { Texture } from 'three'\r\n\r\nexport type LUTProps = {\r\n  lut: Texture\r\n  blendFunction?: BlendFunction\r\n  tetrahedralInterpolation?: boolean\r\n}\r\n\r\nexport const LUT = /* @__PURE__ */ forwardRef(function LUT(\r\n  { lut, tetrahedralInterpolation, ...props }: LUTProps,\r\n  ref: Ref<LUT3DEffect>\r\n) {\r\n  const effect = useMemo(() => new LUT3DEffect(lut, props), [lut, props])\r\n  const invalidate = useThree((state) => state.invalidate)\r\n\r\n  useLayoutEffect(() => {\r\n    if (tetrahedralInterpolation) effect.tetrahedralInterpolation = tetrahedralInterpolation\r\n    if (lut) effect.lut = lut\r\n    invalidate()\r\n  }, [effect, invalidate, lut, tetrahedralInterpolation])\r\n\r\n  return <primitive ref={ref} object={effect} dispose={null} />\r\n})\r\n","import { TiltShiftEffect, BlendFunction } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nexport const TiltShift = /* @__PURE__ */ wrapEffect(TiltShiftEffect, { blendFunction: BlendFunction.ADD })\r\n","import { Uniform } from 'three'\r\nimport { BlendFunction, Effect, EffectAttribute } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nconst TiltShiftShader = {\r\n  fragmentShader: `\r\n\r\n    // original shader by Evan Wallace\r\n\r\n    #define MAX_ITERATIONS 100\r\n\r\n    uniform float blur;\r\n    uniform float taper;\r\n    uniform vec2 start;\r\n    uniform vec2 end;\r\n    uniform vec2 direction;\r\n    uniform int samples;\r\n\r\n    float random(vec3 scale, float seed) {\r\n        /* use the fragment position for a different seed per-pixel */\r\n        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\r\n    }\r\n\r\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n        vec4 color = vec4(0.0);\r\n        float total = 0.0;\r\n        vec2 startPixel = vec2(start.x * resolution.x, start.y * resolution.y);\r\n        vec2 endPixel = vec2(end.x * resolution.x, end.y * resolution.y);\r\n        float f_samples = float(samples);\r\n        float half_samples = f_samples / 2.0;\r\n\r\n        // use screen diagonal to normalize blur radii\r\n        float maxScreenDistance = distance(vec2(0.0), resolution); // diagonal distance\r\n        float gradientRadius = taper * (maxScreenDistance);\r\n        float blurRadius = blur * (maxScreenDistance / 16.0);\r\n\r\n        /* randomize the lookup values to hide the fixed number of samples */\r\n        float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\r\n        vec2 normal = normalize(vec2(startPixel.y - endPixel.y, endPixel.x - startPixel.x));\r\n        float radius = smoothstep(0.0, 1.0, abs(dot(uv * resolution - startPixel, normal)) / gradientRadius) * blurRadius;\r\n\r\n        #pragma unroll_loop_start\r\n        for (int i = 0; i <= MAX_ITERATIONS; i++) {\r\n            if (i >= samples) { break; } // return early if over sample count\r\n            float f_i = float(i);\r\n            float s_i = -half_samples + f_i;\r\n            float percent = (s_i + offset - 0.5) / half_samples;\r\n            float weight = 1.0 - abs(percent);\r\n            vec4 sample_i = texture2D(inputBuffer, uv + normalize(direction) / resolution * percent * radius);\r\n            /* switch to pre-multiplied alpha to correctly blur transparent images */\r\n            sample_i.rgb *= sample_i.a;\r\n            color += sample_i * weight;\r\n            total += weight;\r\n        }\r\n        #pragma unroll_loop_end\r\n\r\n        outputColor = color / total;\r\n\r\n        /* switch back from pre-multiplied alpha */\r\n        outputColor.rgb /= outputColor.a + 0.00001;\r\n    }\r\n    `,\r\n}\r\n\r\nexport class TiltShiftEffect extends Effect {\r\n  constructor({\r\n    blendFunction = BlendFunction.NORMAL,\r\n    blur = 0.15, // [0, 1], can go beyond 1 for extra\r\n    taper = 0.5, // [0, 1], can go beyond 1 for extra\r\n    start = [0.5, 0.0], // [0,1] percentage x,y of screenspace\r\n    end = [0.5, 1.0], // [0,1] percentage x,y of screenspace\r\n    samples = 10.0, // number of blur samples\r\n    direction = [1, 1], // direction of blur\r\n  } = {}) {\r\n    super('TiltShiftEffect', TiltShiftShader.fragmentShader, {\r\n      blendFunction,\r\n      attributes: EffectAttribute.CONVOLUTION,\r\n      uniforms: new Map<string, Uniform<number | number[]>>([\r\n        ['blur', new Uniform(blur)],\r\n        ['taper', new Uniform(taper)],\r\n        ['start', new Uniform(start)],\r\n        ['end', new Uniform(end)],\r\n        ['samples', new Uniform(samples)],\r\n        ['direction', new Uniform(direction)],\r\n      ]),\r\n    })\r\n  }\r\n}\r\n\r\nexport const TiltShift2 = /* @__PURE__ */ wrapEffect(TiltShiftEffect, { blendFunction: BlendFunction.NORMAL })\r\n","// From: https://github.com/emilwidlund/ASCII\r\n// https://twitter.com/emilwidlund/status/1652386482420609024\r\n\r\nimport { forwardRef, useMemo } from 'react'\r\nimport { CanvasTexture, Color, NearestFilter, RepeatWrapping, Texture, Uniform } from 'three'\r\nimport { Effect } from 'postprocessing'\r\n\r\nconst fragment = `\r\nuniform sampler2D uCharacters;\r\nuniform float uCharactersCount;\r\nuniform float uCellSize;\r\nuniform bool uInvert;\r\nuniform vec3 uColor;\r\n\r\nconst vec2 SIZE = vec2(16.);\r\n\r\nvec3 greyscale(vec3 color, float strength) {\r\n    float g = dot(color, vec3(0.299, 0.587, 0.114));\r\n    return mix(color, vec3(g), strength);\r\n}\r\n\r\nvec3 greyscale(vec3 color) {\r\n    return greyscale(color, 1.0);\r\n}\r\n\r\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n    vec2 cell = resolution / uCellSize;\r\n    vec2 grid = 1.0 / cell;\r\n    vec2 pixelizedUV = grid * (0.5 + floor(uv / grid));\r\n    vec4 pixelized = texture2D(inputBuffer, pixelizedUV);\r\n    float greyscaled = greyscale(pixelized.rgb).r;\r\n\r\n    if (uInvert) {\r\n        greyscaled = 1.0 - greyscaled;\r\n    }\r\n\r\n    float characterIndex = floor((uCharactersCount - 1.0) * greyscaled);\r\n    vec2 characterPosition = vec2(mod(characterIndex, SIZE.x), floor(characterIndex / SIZE.y));\r\n    vec2 offset = vec2(characterPosition.x, -characterPosition.y) / SIZE;\r\n    vec2 charUV = mod(uv * (cell / SIZE), 1.0 / SIZE) - vec2(0., 1.0 / SIZE) + offset;\r\n    vec4 asciiCharacter = texture2D(uCharacters, charUV);\r\n\r\n    asciiCharacter.rgb = uColor * asciiCharacter.r;\r\n    asciiCharacter.a = pixelized.a;\r\n    outputColor = asciiCharacter;\r\n}\r\n`\r\n\r\ninterface IASCIIEffectProps {\r\n  font?: string\r\n  characters?: string\r\n  fontSize?: number\r\n  cellSize?: number\r\n  color?: string\r\n  invert?: boolean\r\n}\r\n\r\nclass ASCIIEffect extends Effect {\r\n  constructor({\r\n    font = 'arial',\r\n    characters = ` .:,'-^=*+?!|0#X%WM@`,\r\n    fontSize = 54,\r\n    cellSize = 16,\r\n    color = '#ffffff',\r\n    invert = false,\r\n  }: IASCIIEffectProps = {}) {\r\n    const uniforms = new Map<string, Uniform>([\r\n      ['uCharacters', new Uniform(new Texture())],\r\n      ['uCellSize', new Uniform(cellSize)],\r\n      ['uCharactersCount', new Uniform(characters.length)],\r\n      ['uColor', new Uniform(new Color(color))],\r\n      ['uInvert', new Uniform(invert)],\r\n    ])\r\n\r\n    super('ASCIIEffect', fragment, { uniforms })\r\n\r\n    const charactersTextureUniform = this.uniforms.get('uCharacters')\r\n\r\n    if (charactersTextureUniform) {\r\n      charactersTextureUniform.value = this.createCharactersTexture(characters, font, fontSize)\r\n    }\r\n  }\r\n\r\n  /** Draws the characters on a Canvas and returns a texture */\r\n  public createCharactersTexture(characters: string, font: string, fontSize: number): Texture {\r\n    const canvas = document.createElement('canvas')\r\n    const SIZE = 1024\r\n    const MAX_PER_ROW = 16\r\n    const CELL = SIZE / MAX_PER_ROW\r\n\r\n    canvas.width = canvas.height = SIZE\r\n    const texture = new CanvasTexture(canvas, undefined, RepeatWrapping, RepeatWrapping, NearestFilter, NearestFilter)\r\n    const context = canvas.getContext('2d')\r\n\r\n    if (!context) {\r\n      throw new Error('Context not available')\r\n    }\r\n\r\n    context.clearRect(0, 0, SIZE, SIZE)\r\n    context.font = `${fontSize}px ${font}`\r\n    context.textAlign = 'center'\r\n    context.textBaseline = 'middle'\r\n    context.fillStyle = '#fff'\r\n\r\n    for (let i = 0; i < characters.length; i++) {\r\n      const char = characters[i]\r\n      const x = i % MAX_PER_ROW\r\n      const y = Math.floor(i / MAX_PER_ROW)\r\n      context.fillText(char, x * CELL + CELL / 2, y * CELL + CELL / 2)\r\n    }\r\n\r\n    texture.needsUpdate = true\r\n    return texture\r\n  }\r\n}\r\n\r\nexport const ASCII = /* @__PURE__ */ forwardRef<ASCIIEffect, IASCIIEffectProps>(\r\n  (\r\n    {\r\n      font = 'arial',\r\n      characters = ` .:,'-^=*+?!|0#X%WM@`,\r\n      fontSize = 54,\r\n      cellSize = 16,\r\n      color = '#ffffff',\r\n      invert = false,\r\n    },\r\n    fref\r\n  ) => {\r\n    const effect = useMemo(\r\n      () => new ASCIIEffect({ characters, font, fontSize, cellSize, color, invert }),\r\n      [characters, fontSize, cellSize, color, invert, font]\r\n    )\r\n    return <primitive ref={fref} object={effect} />\r\n  }\r\n)\r\n","import { Uniform } from 'three'\r\nimport { BlendFunction, Effect, EffectAttribute } from 'postprocessing'\r\nimport { wrapEffect } from '../util'\r\n\r\nconst WaterShader = {\r\n  fragmentShader: /* glsl */ `\r\n    uniform float factor;\r\n\r\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\r\n      vec2 vUv = uv;\r\n      float frequency = 6.0 * factor;\r\n      float amplitude = 0.015 * factor;\r\n      float x = vUv.y * frequency + time * 0.7; \r\n      float y = vUv.x * frequency + time * 0.3;\r\n      vUv.x += cos(x + y) * amplitude * cos(y);\r\n      vUv.y += sin(x - y) * amplitude * cos(y);\r\n      vec4 rgba = texture(inputBuffer, vUv);\r\n      outputColor = rgba;\r\n    }\r\n  `,\r\n}\r\n\r\nexport class WaterEffectImpl extends Effect {\r\n  constructor({ blendFunction = BlendFunction.NORMAL, factor = 0 } = {}) {\r\n    super('WaterEffect', WaterShader.fragmentShader, {\r\n      blendFunction,\r\n      attributes: EffectAttribute.CONVOLUTION,\r\n      uniforms: new Map<string, Uniform<number | number[]>>([['factor', new Uniform(factor)]]),\r\n    })\r\n  }\r\n}\r\n\r\nexport const WaterEffect = /* @__PURE__ */ wrapEffect(WaterEffectImpl, {\r\n  blendFunction: BlendFunction.NORMAL,\r\n})\r\n","// From https://github.com/N8python/n8ao\r\n// https://twitter.com/N8Programs/status/1660996748485984261\r\n\r\nimport { Ref, forwardRef, useLayoutEffect, useMemo } from 'react'\r\n/* @ts-ignore */\r\nimport { N8AOPostPass } from 'n8ao'\r\nimport { useThree, ReactThreeFiber, applyProps } from '@react-three/fiber'\r\n\r\nexport type N8AOProps = {\r\n  aoRadius?: number\r\n  distanceFalloff?: number\r\n  intensity?: number\r\n  quality?: 'performance' | 'low' | 'medium' | 'high' | 'ultra'\r\n  aoSamples?: number\r\n  denoiseSamples?: number\r\n  denoiseRadius?: number\r\n  color?: ReactThreeFiber.Color\r\n  halfRes?: boolean\r\n  depthAwareUpsampling?: boolean\r\n  screenSpaceRadius?: boolean\r\n  renderMode?: 0 | 1 | 2 | 3 | 4\r\n}\r\n\r\nexport const N8AO = /* @__PURE__ */ forwardRef<N8AOPostPass, N8AOProps>(\r\n  (\r\n    {\r\n      halfRes,\r\n      screenSpaceRadius,\r\n      quality,\r\n      depthAwareUpsampling = true,\r\n      aoRadius = 5,\r\n      aoSamples = 16,\r\n      denoiseSamples = 4,\r\n      denoiseRadius = 12,\r\n      distanceFalloff = 1,\r\n      intensity = 1,\r\n      color,\r\n      renderMode = 0,\r\n    },\r\n    ref: Ref<N8AOPostPass>\r\n  ) => {\r\n    const { camera, scene } = useThree()\r\n    const effect = useMemo(() => new N8AOPostPass(scene, camera), [camera, scene])\r\n\r\n    // TODO: implement dispose upstream; this effect has memory leaks without\r\n    useLayoutEffect(() => {\r\n      applyProps(effect.configuration, {\r\n        color,\r\n        aoRadius,\r\n        distanceFalloff,\r\n        intensity,\r\n        aoSamples,\r\n        denoiseSamples,\r\n        denoiseRadius,\r\n        screenSpaceRadius,\r\n        renderMode,\r\n        halfRes,\r\n        depthAwareUpsampling,\r\n      })\r\n    }, [\r\n      screenSpaceRadius,\r\n      color,\r\n      aoRadius,\r\n      distanceFalloff,\r\n      intensity,\r\n      aoSamples,\r\n      denoiseSamples,\r\n      denoiseRadius,\r\n      renderMode,\r\n      halfRes,\r\n      depthAwareUpsampling,\r\n      effect,\r\n    ])\r\n\r\n    useLayoutEffect(() => {\r\n      if (quality) effect.setQualityMode(quality.charAt(0).toUpperCase() + quality.slice(1))\r\n    }, [effect, quality])\r\n\r\n    return <primitive ref={ref} object={effect} />\r\n  }\r\n)\r\n"],"mappings":"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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}